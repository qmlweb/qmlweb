{"version":3,"sources":["qt.js","QMLBinding.js","qmlstructure.js","import.js","easing.js","font.js","qrc.js","signal.js","qml.js","AutoLoader.js","jsparser.js","QMLColor.js","QMLEngine.js","QMLInteger.js","QMLList.js","QMLOperationState.js","QMLProperty.js","QMLVariant.js","QObject.js","UpdateGeometry.js","QmlWeb.Dom/DomElement.js","QmlWeb/RestModel.js","Qt.labs.settings/Settings.js","QtGraphicalEffects/FastBlur.js","QtMobility/GeoLocation.js","QtMultimedia/Video.js","QtQml/Component.js","QtQuick.Controls/Button.js","QtQuick.Controls/Checkbox.js","QtQuick.Controls/ComboBox.js","QtQuick.Controls/ScrollView.js","QtQuick.Controls/TextArea.js","QtQuick.Controls/TextField.js","QtQuick.Window/Screen.js","QtQuick/AnimatedImage.js","QtQuick/Animation.js","QtQuick/Behavior.js","QtQuick/BorderImage.js","QtQuick/Canvas.js","QtQuick/Column.js","QtQuick/DoubleValidator.js","QtQuick/Flow.js","QtQuick/Font.js","QtQuick/FontLoader.js","QtQuick/Grid.js","QtQuick/Image.js","QtQuick/IntValidator.js","QtQuick/Item.js","QtQuick/ListElement.js","QtQuick/ListModel.js","QtQuick/ListView.js","QtQuick/Loader.js","QtQuick/MouseArea.js","QtQuick/NumberAnimation.js","QtQuick/ParallelAnimation.js","QtQuick/Positioner.js","QtQuick/PropertyAnimation.js","QtQuick/PropertyChanges.js","QtQuick/QtObject.js","QtQuick/Rectangle.js","QtQuick/RegExpValidator.js","QtQuick/Repeater.js","QtQuick/Rotation.js","QtQuick/Row.js","QtQuick/Scale.js","QtQuick/SequentialAnimation.js","QtQuick/State.js","QtQuick/SystemPalette.js","QtQuick/Text.js","QtQuick/TextEdit.js","QtQuick/TextInput.js","QtQuick/Timer.js","QtQuick/Transition.js","QtQuick/Translate.js","QtWebSockets/WebSocket.js"],"names":[],"mappings":";AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACHA;ADKA;AACA;AACA;AACA;AACA;ACHA;AACA;AACA;ADKA;ACHA;AACA;AACA;AACA;AACA;ADKA;AACA;AACA;AACA;ACHA;AACA;AACA;ADKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AEhCA;AACA;AACA;AACA;AFkCA;AACA;AACA;AACA;AACA;AACA;AACA;AEhCA;AACA;AACA;AACA;AFkCA;AEhCA;AACA;AACA;AACA;AFkCA;AACA;AACA;AACA;AACA;AACA;AEhCA;AACA;AACA;AFkCA;AACA;AACA;AACA;AACA;AEhCA;AFkCA;AACA;AACA;AACA;AACA;AACA;AEhCA;AACA;AACA;AACA;AACA;AFkCA;AACA;AEhCA;AFkCA;AACA;AEhCA;AACA;AACA;AACA;AFkCA;AEhCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AFkCA;AEhCA;AACA;AFkCA;AACA;AEhCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AFkCA;AEhCA;AACA;AACA;AACA;AFkCA;AEhCA;AACA;AACA;AADA;AAGA;AACA;AFkCA;AE3DA;AA4BA;AFkCA;AEhCA;AFkCA;AE/BA;AACA;AACA;AACA;AFiCA;AE/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AFiCA;AE/BA;AACA;AFiCA;AACA;AE/BA;AAEA;AFgCA;AE9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AF+BA;AE7BA;AAIA;AF4BA;AE1BA;AACA;AAEA;AACA;AF2BA;AEzBA;AACA;AAvHA;AFmJA;AEzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AF2BA;AEzBA;AF2BA;AACA;AEzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AF0BA;AACA;AExBA;AACA;AACA;AACA;AACA;AACA;AF0BA;AExBA;AACA;AF0BA;AEvBA;AACA;AACA;AACA;AACA;AFyBA;AEvBA;AACA;AACA;AACA;AFyBA;AExBA;AACA;AACA;AACA;AACA;AACA;AACA;AF0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AGnSA;AHqSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AGnSA;AACA;AACA;AACA;AHqSA;AGnSA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AH4SA;AGvSA;AHySA;AGxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AH0SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AGvSA;AHySA;AACA;AGvSA;AHySA;AGvSA;AAEA;AHwSA;AACA;AACA;AACA;AACA;AACA;AACA;AGtSA;AACA;AACA;AHwSA;AACA;AACA;AGtSA;AACA;AACA;AACA;AHwSA;AGtSA;AACA;AHwSA;AGtSA;AACA;AHwSA;AGtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AHuSA;AI1cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AJwdA;AKxdA;AL0dA;AKxdA;AACA;AACA;AACA;AACA;AL0dA;AKxdA;AACA;AACA;AACA;AACA;AAZA;ALueA;AMveA;AACA;AACA;AACA;AAHA;AN6eA;AA7eA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AA2eA;AAzeA;AACA;AA2eA;AAxeA;AA0eA;AACA;AACA;AACA;AAxeA;AACA;AACA;AACA;AA0eA;AAxeA;AA0eA;AAxeA;AA0eA;AAxeA;AACA;AA0eA;AAxeA;AACA;AACA;AACA;AACA;AACA;AA0eA;AACA;AAxeA;AA0eA;AAveA;AAyeA;AAveA;AAyeA;AAteA;AACA;AACA;AACA;AAweA;AAteA;AAweA;AAteA;AACA;AACA;AAweA;AAteA;AACA;AAweA;AACA;AACA;AAteA;AAweA;AAteA;AAweA;AAteA;AACA;AACA;AACA;AAweA;AAteA;AACA;AACA;AAweA;AAteA;AAweA;AACA;AAteA;AAweA;AAteA;AACA;AAweA;AAteA;AACA;AAweA;AACA;AACA;AAteA;AAEA;AACA;AAueA;AACA;AACA;AAreA;AAueA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApeA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAqeA;AAneA;AACA;AAqeA;AACA;AAneA;AACA;AACA;AAqeA;AAneA;AACA;AACA;AACA;AACA;AACA;AAqeA;AAneA;AACA;AAqeA;AAneA;AACA;AAqeA;AAneA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqeA;AAneA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqeA;AAneA;AACA;AACA;AACA;AACA;AAqeA;AAneA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqeA;AAneA;AACA;AACA;AAzVA;AA+zBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AO/zBA;AACA;AACA;AACA;APi0BA;AO/zBA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAMA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AP8zBA;AACA;AO5zBA;AACA;AACA;AAEA;AACA;AP6zBA;AACA;AO3zBA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;APuzBA;AACA;AOrzBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;APkzBA;AACA;AACA;AACA;AQl4BA;ARo4BA;AQl4BA;ARo4BA;AACA;AQl4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;ARg5BA;AQl4BA;AACA;AADA;ARs4BA;AQl4BA;ARo4BA;AACA;AQl4BA;AACA;AACA;AACA;AACA;ARo4BA;AACA;AQl4BA;AACA;ARo4BA;AQl4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;ARq4BA;AQn4BA;AACA;ARq4BA;AQn4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ARq4BA;AQn4BA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;ARy4BA;AQn4BA;AAEA;AACA;ARo4BA;AQl4BA;AACA;AACA;ARo4BA;AQl4BA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;ARs4BA;AQp4BA;AACA;AACA;AACA;ARs4BA;AQp4BA;AAEA;AACA;AACA;AACA;ARq4BA;AQn4BA;AACA;ARq4BA;AQn4BA;AACA;AACA;AACA;AACA;AACA;ARq4BA;AQn4BA;AACA;AACA;AACA;AACA;AACA;ARq4BA;AQn4BA;AACA;ARq4BA;AQn4BA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;ARy4BA;AQv4BA;ARy4BA;AQv4BA;AACA;AACA;AACA;ARy4BA;AACA;AACA;AACA;AQv4BA;AAIA;AACA;AACA;ARs4BA;AQp4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ARs4BA;AQp4BA;AACA;AACA;AACA;ARs4BA;AACA;AACA;AACA;AACA;AACA;AQp4BA;AACA;ARs4BA;AQn4BA;AACA;AACA;AACA;AACA;ARq4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQl4BA;AACA;ARo4BA;AQl4BA;AACA;ARo4BA;AQh4BA;AACA;ARk4BA;AQh4BA;AAEA;AACA;AACA;AACA;AACA;ARi4BA;AACA;AQ/3BA;ARi4BA;AACA;AQ93BA;ARg4BA;AACA;AQ93BA;ARg4BA;AQ93BA;AACA;ARg4BA;AACA;AACA;AACA;AACA;AACA;AACA;AQ93BA;AAAA;ARi4BA;AQh4BA;AACA;ARk4BA;AQh4BA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;ARk4BA;AACA;AACA;AACA;AACA;AQh4BA;AACA;AACA;AACA;AACA;AAHA;AAKA;ARk4BA;AQh4BA;AACA;AACA;AACA;AACA;AAHA;AAKA;ARk4BA;AQh4BA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;ARk4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AQh4BA;AACA;AACA;AACA;AACA;AACA;ARk4BA;AQh4BA;AACA;AACA;ARk4BA;AQh4BA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ARi4BA;AQ/3BA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AR+3BA;AACA;AACA;AQ73BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AR83BA;AQ53BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AR83BA;AACA;AACA;AACA;AACA;AACA;AACA;AQ53BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AR83BA;AQ53BA;AACA;AACA;AACA;AACA;AACA;AR83BA;AQ53BA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAIA;ARo3BA;AACA;AQl3BA;AAEA;ARm3BA;AACA;AQj3BA;AACA;ARm3BA;AQj3BA;AACA;AACA;ARm3BA;AQj3BA;AAIA;AAIA;AAKA;AAIA;AACA;ARs2BA;AACA;AACA;AACA;AACA;AACA;AQp2BA;AACA;AACA;ARs2BA;AStyCA;AACA;ATwyCA;AStyCA;AACA;AACA;ATwyCA;AStyCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ATwyCA;AUtzCA;AVwzCA;AUtzCA;AAIA;AAAA;AAEA;AVqzCA;AUnzCA;AACA;AACA;AACA;AACA;AVqzCA;AUnzCA;AACA;AVqzCA;AUnzCA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AVqzCA;AACA;AWl1CA;AACA;AXo1CA;AACA;AWl1CA;AACA;AACA;AXo1CA;AWl1CA;AACA;AACA;AACA;AACA;AACA;AXo1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AYl2CA;AZo2CA;AACA;AYl2CA;AZo2CA;AYl2CA;AACA;AACA;AZo2CA;AACA;AYl2CA;AZo2CA;AYl2CA;AZo2CA;AACA;AYl2CA;AZo2CA;AACA;AYl2CA;AZo2CA;AACA;AYl2CA;AZo2CA;AACA;AYl2CA;AZo2CA;AACA;AYl2CA;AZo2CA;AACA;AYl2CA;AZo2CA;AACA;AACA;AYj2CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AZk2CA;AACA;AYh2CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AZi2CA;AY91CA;AACA;AACA;AZg2CA;AY91CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AZg2CA;AY91CA;AACA;AACA;AACA;AACA;AACA;AZg2CA;AY91CA;AACA;AZg2CA;AY91CA;AACA;AACA;AACA;AACA;AZg2CA;AACA;AY91CA;AZg2CA;AY/1CA;AACA;AZi2CA;AY/1CA;AACA;AACA;AACA;AACA;AZi2CA;AACA;AY/1CA;AZi2CA;AY/1CA;AACA;AACA;AACA;AZi2CA;AY/1CA;AACA;AACA;AZi2CA;AY/1CA;AZi2CA;AY/1CA;AACA;AZi2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AY/1CA;AACA;AACA;AACA;AZi2CA;AY/1CA;AACA;AZi2CA;AY/1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AZi2CA;AY/1CA;AACA;AZi2CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AYn1CA;AACA;AZq1CA;AACA;AYn1CA;AZq1CA;AYn1CA;AACA;AZq1CA;AYn1CA;AACA;AZq1CA;AYn1CA;AZq1CA;AYn1CA;AACA;AACA;AZq1CA;AYn1CA;AZq1CA;AACA;AYn1CA;AACA;AAEA;AZo1CA;AACA;AACA;AYl1CA;AZo1CA;AYl1CA;AACA;AZo1CA;AYl1CA;AACA;AZo1CA;AACA;AACA;AYh1CA;AACA;AZk1CA;AY90CA;AACA;AZg1CA;AY90CA;AACA;AACA;AACA;AACA;AACA;AZg1CA;AY90CA;AACA;AZg1CA;AACA;AY90CA;AZg1CA;AACA;AACA;AACA;AACA;AACA;AACA;AY90CA;AZg1CA;AY70CA;AACA;AZ+0CA;AACA;AACA;AY70CA;AAAA;AAAA;AZi1CA;AACA;AY/0CA;AACA;AAEA;AZg1CA;AY90CA;AACA;AACA;AZg1CA;AY90CA;AACA;AACA;AZg1CA;AACA;AY90CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AZg1CA;AY90CA;AACA;AACA;AAIA;AACA;AZ60CA;AY30CA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAVA;AAYA;AZy0CA;AYv0CA;AACA;AACA;AACA;AZy0CA;AYv0CA;AACA;AZy0CA;AYv0CA;AACA;AACA;AAEA;AACA;AAIA;AACA;AZq0CA;AYn0CA;AACA;AACA;AZq0CA;AYn0CA;AACA;AZq0CA;AYn0CA;AACA;AACA;AACA;AAIA;AACA;AZk0CA;AACA;AYh0CA;AAEA;AACA;AZi0CA;AY/zCA;AACA;AZi0CA;AY9zCA;AACA;AZg0CA;AY9zCA;AACA;AZg0CA;AY9zCA;AACA;AADA;AAEA;AZi0CA;AY/zCA;AACA;AZi0CA;AACA;AACA;AACA;AACA;AY/zCA;AACA;AACA;AACA;AZi0CA;AY/zCA;AAEA;AACA;AZg0CA;AY9zCA;AACA;AACA;AZg0CA;AACA;AACA;AACA;AACA;AY9zCA;AZg0CA;AACA;AY9zCA;AZg0CA;AACA;AY7zCA;AACA;AACA;AZ+zCA;AACA;AACA;AACA;AY7zCA;AAEA;AZ8zCA;AY3zCA;AZ6zCA;AY3zCA;AACA;AACA;AACA;AACA;AZ6zCA;AY3zCA;AZ6zCA;AY3zCA;AACA;AACA;AAEA;AACA;AACA;AACA;AZ4zCA;AY1zCA;AACA;AZ4zCA;AY1zCA;AZ4zCA;AY1zCA;AACA;AACA;AACA;AACA;AACA;AZ4zCA;AACA;AY1zCA;AZ4zCA;AYzzCA;AACA;AACA;AACA;AACA;AZ2zCA;AYzzCA;AAEA;AACA;AZ0zCA;AYxzCA;AAEA;AACA;AZyzCA;AYvzCA;AAEA;AACA;AZwzCA;AYtzCA;AAEA;AACA;AACA;AACA;AACA;AZuzCA;AYrzCA;AAEA;AACA;AZszCA;AACA;AACA;AYpzCA;AAEA;AZqzCA;AACA;AYnzCA;AACA;AACA;AACA;AACA;AZqzCA;AACA;AACA;AYlzCA;AACA;AZozCA;AACA;AACA;AYnzCA;AZqzCA;AACA;AACA;AACA;AACA;AACA;AYlzCA;AZozCA;AYlzCA;AZozCA;AYlzCA;AACA;AACA;AACA;AACA;AACA;AZozCA;AACA;AYlzCA;AACA;AAEA;AACA;AZmzCA;AYjzCA;AZmzCA;AACA;AYjzCA;AACA;AACA;AACA;AACA;AZmzCA;Aa/3DA;AACA;AACA;Abi4DA;Acn4DA;AACA;AACA;AAEA;AADA;Ads4DA;Acj4DA;AACA;Adm4DA;Ae54DA;AACA;AACA;AACA;AAHA;Afk5DA;AgBl5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AhBo5DA;AACA;AACA;AgBl5DA;AACA;AhBo5DA;AgBl5DA;AACA;AACA;AhBo5DA;AACA;AACA;AgBl5DA;AACA;AhBo5DA;AgBj5DA;AACA;AACA;AACA;AhBm5DA;AgBj5DA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AhBm5DA;AgBj5DA;AAEA;AhBk5DA;AACA;AgBh5DA;AhBk5DA;AACA;AgBh5DA;AhBk5DA;AgB/4DA;AACA;AhBi5DA;AgB/4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AhBy5DA;AACA;AgB/4DA;AACA;AhBi5DA;AACA;AgB/4DA;AACA;AAEA;AACA;AACA;AhBg5DA;AgB94DA;AACA;AhBg5DA;AgB74DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AhB64DA;AgB34DA;AACA;AACA;AACA;AACA;AhB64DA;AgB34DA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AhB04DA;AgBx4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AhB04DA;AgBz4DA;AACA;AACA;AACA;AACA;AACA;AhB24DA;AiB9gEA;AACA;AACA;AjBghEA;AACA;AkBlhEA;AACA;AACA;AACA;AlBohEA;AkBjhEA;AACA;AlBmhEA;AkBjhEA;AACA;AACA;AlBmhEA;AkBhhEA;AACA;AACA;AACA;AAEA;AACA;AlBihEA;AkB/gEA;AACA;AACA;AACA;AADA;AAEA;AlBkhEA;AkBhhEA;AlBkhEA;AACA;AACA;AACA;AkB/gEA;AACA;AlBihEA;AACA;AACA;AkB/gEA;AACA;AlBihEA;AmB1jEA;AACA;AACA;AAEA;AnB2jEA;AmBzjEA;AnB2jEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmB/jEA;AnBikEA;AACA;AmB5jEA;AACA;AAEA;AnB6jEA;AmB1jEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnB4jEA;AmBzjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnB2jEA;AmBxjEA;AACA;AACA;AACA;AACA;AnB0jEA;AmBxjEA;AAEA;AAEA;AAEA;AAEA;AnBsjEA;AmBnjEA;AnBqjEA;AmBnjEA;AACA;AnBqjEA;AmBnjEA;AACA;AACA;AAEA;AnBojEA;AmBljEA;AnBojEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmBxjEA;AnB0jEA;AACA;AmBrjEA;AACA;AAEA;AnBsjEA;AmBnjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnBqjEA;AmBljEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnBojEA;AmBjjEA;AACA;AACA;AACA;AACA;AnBmjEA;AmBjjEA;AAEA;AAEA;AAEA;AAEA;AnB+iEA;AmB5iEA;AnB8iEA;AmB5iEA;AACA;AnB8iEA;AmB5iEA;AACA;AACA;AnB8iEA;AmB3iEA;AACA;AACA;AACA;AACA;AnB6iEA;AmB3iEA;AACA;AACA;AACA;AACA;AACA;AACA;AnB6iEA;AmB3iEA;AACA;AACA;AACA;AACA;AnB6iEA;AoB9wEA;AACA;AACA;AACA;ApBgxEA;AoB9wEA;ApBgxEA;AACA;AoB9wEA;ApBgxEA;AoB9wEA;AACA;AACA;AACA;AACA;AACA;AALA;ApBsxEA;AqBhyEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArBkyEA;AqBhyEA;AACA;AACA;AACA;ArBkyEA;AqBhyEA;AACA;AACA;AACA;ArBkyEA;AqBhyEA;AACA;ArBkyEA;AqBhyEA;ArBkyEA;AqBhyEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;ArBkyEA;AqBhyEA;AACA;AACA;ArBkyEA;AqBhyEA;AACA;AACA;ArBkyEA;AqBhyEA;AACA;ArBkyEA;AqBhyEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;ArBkyEA;AqBhyEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;ArBkyEA;AqBhyEA;AACA;AACA;ArBkyEA;AqBhyEA;AACA;AADA;AAGA;AAIA;AACA;ArB+xEA;AqB7xEA;AACA;AACA;AACA;AACA;ArB+xEA;AqB7xEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;ArB0xEA;AqBxxEA;AACA;ArB0xEA;AqBxxEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;ArBoxEA;AqBlxEA;AACA;ArBoxEA;AqBlxEA;AACA;AACA;AACA;AACA;ArBoxEA;AqBlxEA;AACA;AACA;AACA;AACA;AACA;AACA;ArBoxEA;AqBlxEA;AACA;AACA;AACA;AAvJA;ArB46EA;AsB56EA;AACA;AACA;AACA;AACA;AACA;AACA;AtB86EA;AsB56EA;AtB86EA;AsB56EA;AtB86EA;AsB36EA;AtB66EA;AsB36EA;AACA;AACA;AtB66EA;AsB36EA;AACA;AACA;AACA;AACA;AtB66EA;AsB36EA;AACA;AACA;AACA;AACA;AtB66EA;AsB36EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AtB66EA;AsB36EA;AACA;AACA;AACA;AACA;AACA;AA9CA;AtB49EA;AuB59EA;AACA;AACA;AACA;AACA;AACA;AACA;AvB89EA;AuB59EA;AACA;AvB89EA;AuB59EA;AACA;AACA;AACA;AvB89EA;AuB59EA;AACA;AACA;AACA;AACA;AAHA;AAKA;AvB89EA;AuB59EA;AACA;AACA;AvB89EA;AuB59EA;AACA;AACA;AACA;AvB89EA;AuB59EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AvB89EA;AuB59EA;AACA;AACA;AvB89EA;AuB59EA;AACA;AACA;AACA;AAtDA;AvBqhFA;AwBrhFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AxBuhFA;AwBrhFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AxBuhFA;AwBrhFA;AACA;AACA;AxBuhFA;AwBrhFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AxBuhFA;AwBrhFA;AACA;AACA;AApCA;AxB4jFA;AyB5jFA;AACA;AACA;AACA;AAHA;AzBkkFA;AyB5jFA;AACA;AADA;AzBgkFA;AyB5jFA;AACA;AACA;AACA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AACA;AACA;AzB8jFA;AyB5jFA;AzB8jFA;AyB3jFA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AzBmkFA;AyB3jFA;AAEA;AACA;AzB4jFA;AyB1jFA;AACA;AACA;AzB4jFA;AyB1jFA;AACA;AAEA;AzB2jFA;AyBzjFA;AACA;AAEA;AzB0jFA;AyBxjFA;AACA;AAEA;AzByjFA;AyBvjFA;AACA;AAEA;AzBwjFA;AyBtjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AzBwjFA;AyBtjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAtLA;AzB+uFA;A0BzvFA;AACA;AACA;AACA;AAEA;AACA;AACA;A1B0vFA;A0BxvFA;A1B0vFA;A0BzvFA;AACA;AACA;AACA;A1B2vFA;A0BzvFA;AACA;AACA;AACA;A1B2vFA;A0BzvFA;AACA;AACA;A1B2vFA;A0BzvFA;A1B2vFA;A0BzvFA;AACA;AACA;AACA;AACA;AAJA;A1BgwFA;AACA;AACA;A0BzvFA;A1B2vFA;A0BzvFA;AACA;AACA;A1B2vFA;A0BzvFA;AACA;AAIA;A1BwvFA;A0BtvFA;A1BwvFA;A0BtvFA;AACA;AACA;AACA;AACA;A1BwvFA;A0BtvFA;AAEA;AAIA;AACA;AACA;AACA;AAGA;AACA;A1BkvFA;A0BhvFA;AAEA;AACA;AACA;AAIA;A1B8uFA;A0B5uFA;AACA;AACA;AACA;AACA;AAEA;AACA;A1B6uFA;A0B3uFA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;A1BovFA;A2B90FA;AAAA;A3Bi1FA;A2Bh1FA;A3Bk1FA;A2Bh1FA;AACA;AACA;A3Bk1FA;A2Bh1FA;AACA;AACA;A3Bk1FA;A2Bh1FA;AACA;AACA;AACA;AACA;AACA;A3Bk1FA;A2Bh1FA;AACA;AACA;AACA;AACA;AACA;A3Bk1FA;A2Bh1FA;AACA;AACA;AACA;A3Bk1FA;A2Bh1FA;AACA;AACA;AACA;AACA;AACA;AALA;A3Bw1FA;A4Bt3FA;AACA;AACA;AACA;AACA;AACA;AACA;A5Bw3FA;A4Bt3FA;AACA;A5Bw3FA;A4Bt3FA;AACA;AACA;AACA;A5Bw3FA;A4Bt3FA;AACA;A5Bw3FA;A4Bt3FA;A5Bw3FA;A4Bt3FA;A5Bw3FA;A4Bt3FA;AACA;A5Bw3FA;A4Bt3FA;AACA;AACA;A5Bw3FA;A4Bt3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A5Bw3FA;A4Bt3FA;AACA;AACA;A5Bw3FA;A4Bt3FA;AACA;AACA;AACA;AAlDA;A5B26FA;A6B36FA;AACA;AACA;AACA;AACA;AACA;AALA;A7Bm7FA;A6B36FA;AACA;AACA;A7B66FA;A6B36FA;AACA;A7B66FA;A6B36FA;AACA;AACA;AACA;AACA;AACA;A7B66FA;A6B36FA;AACA;AACA;AACA;AACA;AACA;A7B66FA;A6B36FA;AACA;AACA;AACA;A7B66FA;A6B36FA;AACA;AACA;A7B66FA;A6B36FA;AACA;A7B66FA;AACA;AACA;AACA;AACA;AACA;A6B36FA;AACA;AACA;AACA;AACA;A7B66FA;A6B36FA;AACA;A7B66FA;A6B36FA;AACA;AACA;AACA;AACA;AACA;AACA;A7B66FA;A6B36FA;AACA;AACA;AACA;AACA;AACA;A7B66FA;A6B36FA;A7B66FA;A6B36FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A7B66FA;A8B5/FA;AACA;A9B8/FA;A8B5/FA;A9B8/FA;A8B5/FA;AACA;A9B8/FA;A8B5/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A9B8/FA;A8B5/FA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;A9B4/FA;A8Bz/FA;AACA;AACA;AACA;AACA;AACA;A9B2/FA;A8Bz/FA;A9B2/FA;AACA;A8Bz/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A9B2/FA;A8Bz/FA;AACA;AACA;AACA;A9B2/FA;A8Bz/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A9B2/FA;A8Bz/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;A9B2/FA;A8Bz/FA;AACA;AACA;AACA;AACA;AACA;AALA;A9BigGA;A+BhlGA;AACA;AACA;AACA;AACA;AACA;AACA;A/BklGA;A+BhlGA;AACA;AACA;AACA;AACA;AACA;AALA;A/BwlGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AgChmGA;AACA;AACA;AACA;AACA;AACA;AALA;AhCwmGA;AgChmGA;AACA;AhCkmGA;AgChmGA;AhCkmGA;AgChmGA;AhCkmGA;AgChmGA;AACA;AACA;AACA;AACA;AACA;AACA;AhCkmGA;AgChmGA;AhCkmGA;AgChmGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AhCkmGA;AgChmGA;AACA;AACA;AACA;AhCkmGA;AgChmGA;AACA;AACA;AhCkmGA;AgChmGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AhCkmGA;AgChmGA;AACA;AAEA;AACA;AhCimGA;AgC/lGA;AACA;AACA;AhCimGA;AgC/lGA;AACA;AAEA;AACA;AACA;AACA;AhCgmGA;AgC9lGA;AACA;AAEA;AACA;AhC+lGA;AgC7lGA;AACA;AACA;AACA;AACA;AACA;AACA;AhC+lGA;AgC7lGA;AACA;AACA;AhC+lGA;AiCpsGA;AACA;AACA;AACA;AACA;AACA;AALA;AjC4sGA;AiCpsGA;AACA;AACA;AjCssGA;AACA;AACA;AiCpsGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AjCssGA;AiCpsGA;AjCssGA;AiCpsGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AjCssGA;AkC7uGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AlCuvGA;AmCvvGA;AACA;AnCyvGA;AACA;AmCvvGA;AACA;AADA;AnC2vGA;AmCvvGA;AACA;AACA;AACA;AnCyvGA;AACA;AmCvvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AnCyvGA;AACA;AmCvvGA;AACA;AnCyvGA;AmCvvGA;AACA;AACA;AACA;AACA;AACA;AALA;AnC+vGA;AoClyGA;AACA;AACA;AACA;AACA;AACA;AACA;ApCoyGA;AoClyGA;AACA;AACA;ApCoyGA;AoClyGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;ApCyzGA;AqCzzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArC2zGA;AqCzzGA;ArC2zGA;AqCzzGA;AACA;AACA;ArC2zGA;AqCzzGA;AACA;AACA;AACA;AATA;ArCq0GA;AqCzzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArC2zGA;AqCzzGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArC2zGA;AqCzzGA;AACA;AACA;AAKA;AAEA;ArCszGA;AqCjzGA;AACA;AAKA;AAEA;ArC8yGA;AqCzyGA;AACA;AAKA;AAEA;ArCsyGA;AqCjyGA;AAKA;AAEA;AAIA;AACA;AA7FA;ArCy3GA;AACA;AACA;AACA;AsCz3GA;AACA;AACA;AACA;AACA;AACA;AACA;AtC23GA;AsCz3GA;AtC23GA;AsCz3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AtC23GA;AsCz3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AtC23GA;AsCz3GA;AACA;AACA;AtC23GA;AsCz3GA;AACA;AACA;AtC23GA;AsCz3GA;AACA;AACA;AACA;AtC23GA;AsCz3GA;AACA;AACA;AtC23GA;AsCz3GA;AACA;AACA;AtC23GA;AsCz3GA;AACA;AACA;AtC23GA;AsCz3GA;AtC23GA;AsCz3GA;AAEA;AtC03GA;AsCx3GA;AtC03GA;AsCx3GA;AACA;AtC03GA;AsCx3GA;AACA;AACA;AtC03GA;AsCx3GA;AtC03GA;AsCv3GA;AACA;AACA;AtCy3GA;AsCv3GA;AACA;AACA;AtCy3GA;AsCv3GA;AAEA;AAjFA;AtC08GA;AuC78GA;AACA;AACA;AvC+8GA;AuC78GA;AACA;AvC+8GA;AuC78GA;AACA;AACA;AAEA;AvC88GA;AuC58GA;AACA;AACA;AACA;AACA;AACA;AvC88GA;AuC58GA;AACA;AACA;AACA;AACA;AACA;AALA;AvCo9GA;AwCx+GA;AACA;AADA;AxC4+GA;AwCx+GA;AACA;AACA;AACA;AACA;AACA;AACA;AxC0+GA;AwCx+GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AxC0+GA;AwCx+GA;AACA;AxC0+GA;AwCx+GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AxC0+GA;AwCx+GA;AACA;AACA;AxC0+GA;AwCx+GA;AAAA;AACA;AACA;AACA;AxC2+GA;AwCz+GA;AACA;AACA;AxC2+GA;AwCz+GA;AACA;AxC2+GA;AwCz+GA;AACA;AACA;AACA;AACA;AACA;AArDA;AxCiiHA;AyCriHA;AACA;AzCuiHA;AyCriHA;AACA;AACA;AAFA;AzC0iHA;AyCriHA;AACA;AzCuiHA;AyCriHA;AACA;AACA;AACA;AACA;AzCuiHA;AyCriHA;AACA;AzCuiHA;AACA;AyCriHA;AACA;AACA;AzCuiHA;AyCpiHA;AACA;AACA;AACA;AACA;AACA;AACA;AzCsiHA;AyCpiHA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AzCqiHA;AyCniHA;AAEA;AACA;AACA;AACA;AACA;AAIA;AzCiiHA;AyC/hHA;AACA;AACA;AACA;AACA;AACA;AALA;AzCuiHA;A0CjmHA;AACA;AACA;AACA;AACA;AACA;AAAA;A1ComHA;A0CnmHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A1CqmHA;A0CnmHA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAKA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AA3EA;A1CoqHA;A2CpqHA;AACA;AACA;AACA;AACA;AACA;AACA;A3CsqHA;AACA;A2CpqHA;A3CsqHA;A2CpqHA;AACA;AACA;AACA;AALA;A3C4qHA;A2CpqHA;AACA;AACA;A3CsqHA;A2CpqHA;A3CsqHA;A2CpqHA;A3CsqHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A2CpqHA;A3CsqHA;A2CpqHA;AACA;AAEA;AACA;AACA;A3CqqHA;A2CnqHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A3CqqHA;A2CnqHA;AACA;AAEA;A3CoqHA;A2ClqHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A3CoqHA;A2ClqHA;AACA;AACA;AACA;AACA;AACA;A3CoqHA;A2ClqHA;AACA;AAvGA;A3C4wHA;A4C5wHA;AACA;AACA;AACA;AACA;AACA;AALA;A5CoxHA;A4C5wHA;AACA;A5C8wHA;A4C5wHA;AACA;AACA;AAFA;A5CixHA;A4C5wHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A5C8wHA;A4C5wHA;AACA;A5C8wHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A4C7wHA;AACA;AACA;AAEA;A5C8wHA;AACA;A4C5wHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A5C8wHA;AACA;A4C5wHA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;A5CqwHA;A4CnwHA;AACA;AADA;AAGA;AADA;A5CuwHA;A4ClwHA;A5CowHA;AACA;A4ClwHA;AAEA;AACA;AACA;AAEA;AACA;A5CkwHA;A4ChwHA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;A5C+vHA;A4C7vHA;AACA;AACA;AACA;AACA;A5C+vHA;A4C7vHA;AACA;AACA;A5C+vHA;A6C13HA;AACA;AACA;A7C43HA;AACA;AACA;A6C13HA;A7C43HA;A6C13HA;AACA;AACA;AACA;AACA;AACA;A7C43HA;A6C13HA;AACA;AACA;AACA;AAZA;A7Cy4HA;AACA;A6C13HA;AACA;AACA;A7C43HA;A6C13HA;AACA;AACA;AACA;AACA;A7C43HA;A6C13HA;A7C43HA;A6C13HA;AACA;A7C43HA;A6C13HA;AACA;AACA;AACA;A7C43HA;AACA;A6C13HA;AACA;AACA;AACA;AACA;AACA;AACA;A7C43HA;A6C13HA;AACA;AACA;AACA;AACA;AACA;A7C43HA;A6C13HA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;AAiCA;AACA;A7C23HA;A6Cz3HA;AACA;AACA;AAEA;A7C03HA;A6Cx3HA;AAEA;AAGA;AACA;A7Cu3HA;A6Cr3HA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;A7Cs3HA;A6Cp3HA;AACA;AACA;A7Cs3HA;A6Cp3HA;AACA;AACA;AACA;AACA;AACA;AALA;A7C43HA;A8Cz/HA;AACA;AACA;AACA;AACA;AACA;AACA;A9C2/HA;A8Cz/HA;AACA;AACA;AACA;A9C2/HA;A8Cz/HA;AACA;AACA;A9C2/HA;A8Cz/HA;AACA;A9C2/HA;A8Cz/HA;AACA;AACA;AACA;AACA;AAxBA;A9CohIA;A+CphIA;AACA;AACA;A/CshIA;A+CnhIA;A/CqhIA;A+CphIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/CshIA;A+CphIA;A/CshIA;A+CphIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;A/CohIA;A+ClhIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/CmhIA;A+CjhIA;A/CmhIA;A+CjhIA;AACA;AACA;AACA;AACA;AACA;A/CmhIA;A+CjhIA;AACA;AACA;A/CmhIA;A+CjhIA;AAEA;AACA;AACA;AACA;A/CkhIA;A+ChhIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/CihIA;A+C/gIA;AACA;A/CihIA;A+C/gIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/CihIA;AACA;A+C/gIA;AACA;AACA;AACA;AACA;A/CihIA;A+C/gIA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;A/CmhIA;AACA;A+C3gIA;AACA;AACA;AACA;AACA;AACA;A/C6gIA;AACA;A+C3gIA;AACA;A/C6gIA;A+C3gIA;AACA;A/C6gIA;A+C3gIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AANA;A/CkhIA;AACA;A+CxgIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAPA;AAUA;AACA;AACA;AAEA;AACA;AANA;AAQA;AACA;AACA;A/CsgIA;AACA;AACA;AACA;A+CpgIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/CqgIA;AACA;A+CngIA;A/CqgIA;A+CngIA;AACA;A/CqgIA;A+CngIA;A/CqgIA;A+CngIA;AAMA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;A/C0/HA;A+Cx/HA;AACA;AACA;A/C0/HA;A+Cx/HA;AACA;AACA;AACA;A/C0/HA;A+Cx/HA;AACA;AACA;AAOA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/Cg/HA;A+C9+HA;AACA;AACA;AACA;AACA;A/Cg/HA;A+C9+HA;AACA;AACA;AACA;A/Cg/HA;AACA;A+C9+HA;AACA;A/Cg/HA;AACA;AACA;A+C9+HA;AACA;AACA;AACA;AACA;AACA;AACA;A/Cg/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A+C9+HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/Cg/HA;A+C9+HA;A/Cg/HA;A+C9+HA;A/Cg/HA;A+C/+HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A/Ci/HA;A+C/+HA;AACA;AACA;AACA;AACA;AACA;AALA;A/Cu/HA;AgD53IA;AACA;AACA;AACA;AACA;AACA;AACA;AhD83IA;AgD53IA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AhD64IA;AiD74IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AjD+4IA;AiD74IA;AjD+4IA;AiD74IA;AACA;AACA;AACA;AjD+4IA;AiD74IA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AjD84IA;AiD54IA;AACA;AACA;AACA;AACA;AACA;AjD84IA;AiD54IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxEA;AjDu9IA;AkDv9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AlDy9IA;AkDv9IA;AACA;AlDy9IA;AkDv9IA;AAAA;AAAA;AACA;AACA;AACA;AACA;AlD29IA;AkDz9IA;AlD29IA;AkDz9IA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AlDw9IA;AkDt9IA;AACA;AACA;AACA;AACA;AACA;AAvCA;AlDggJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AmDhgJA;AACA;AACA;AACA;AACA;AACA;AACA;AnDkgJA;AmDhgJA;AnDkgJA;AmDhgJA;AACA;AACA;AACA;AACA;AACA;AACA;AnDkgJA;AmDhgJA;AACA;AACA;AACA;AACA;AACA;AACA;AnDkgJA;AmDhgJA;AnDkgJA;AmDhgJA;AACA;AACA;AnDkgJA;AmDhgJA;AACA;AACA;AnDkgJA;AmDhgJA;AACA;AACA;AACA;AACA;AACA;AAEA;AA3CA;AnD6iJA;AoD1jJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApD4jJA;AoD1jJA;ApD4jJA;AACA;AACA;AACA;AoD1jJA;AACA;ApD4jJA;AoD1jJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApD4jJA;AoD1jJA;AACA;AACA;AACA;ApD4jJA;AoD1jJA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAXA;AAaA;AACA;AACA;ApDsjJA;AoDpjJA;AACA;AACA;ApDsjJA;AoDpjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ApDsjJA;AoDpjJA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;ApD4kJA;AACA;AoDnmJA;AA0BA;AACA;ApD4kJA;AoD1kJA;AACA;AACA;AACA;AAzHA;ApDssJA;AqDtsJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArDwsJA;AACA;AACA;AqDtsJA;ArDwsJA;AqDtsJA;AACA;ArDwsJA;AqDvsJA;AAEA;AACA;AAIA;ArDqsJA;AqDnsJA;AACA;AACA;AACA;ArDqsJA;AqDnsJA;AACA;AACA;AACA;AACA;AACA;AACA;ArDqsJA;AqDnsJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArDqsJA;AqDnsJA;AACA;AACA;AACA;AACA;ArDqsJA;AqDnsJA;AAMA;AACA;AA9DA;ArD+vJA;AsD/vJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AtDiwJA;AsD7vJA;AACA;AACA;AACA;AtD+vJA;AsD7vJA;AACA;AACA;AAEA;AACA;AtD8vJA;AsD5vJA;AACA;AACA;AAEA;AtD6vJA;AsD3vJA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AtD8vJA;AsD5vJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtDA;AtDqzJA;AuDrzJA;AACA;AvDuzJA;AuDrzJA;AACA;AACA;AACA;AvDuzJA;AuDrzJA;AACA;AvDuzJA;AuDrzJA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AvDozJA;AuDlzJA;AACA;AACA;AACA;AACA;AACA;AALA;AvD0zJA;AwDj1JA;AACA;AACA;AACA;AACA;AACA;AACA;AxDm1JA;AwDj1JA;AACA;AACA;AACA;AACA;AACA;AACA;AxDm1JA;AwDj1JA;AACA;AACA;AACA;AACA;AxDm1JA;AwDj1JA;AACA;AxDm1JA;AwDj1JA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AxDm1JA;AwDj1JA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AxDo1JA;AwDl1JA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AxDo1JA;AwDl1JA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AxDo1JA;AwDl1JA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AxDs1JA;AwDp1JA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AxDs1JA;AwDp1JA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AxDs1JA;AwDp1JA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAGA;AACA;AAIA;AxD40JA;AwDx0JA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AxD00JA;AwDx0JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AxD00JA;AwDx0JA;AACA;AxD00JA;AwDx0JA;AACA;AA7IA;AA+IA;AxD00JA;AwDx0JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AxD00JA;AACA;AwDx0JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AxD00JA;AwDx0JA;AAEA;AACA;AACA;AxDy0JA;AwDv0JA;AAEA;AxDw0JA;AwDt0JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AxDw0JA;AwDt0JA;AACA;AACA;AACA;AxDw0JA;AwDt0JA;AACA;AACA;AACA;AACA;AAjOA;AxD0iKA;AyD1iKA;AACA;AzD4iKA;AyD1iKA;AACA;AACA;AzD4iKA;AyD1iKA;AzD4iKA;AyD1iKA;AACA;AACA;AACA;AAFA;AAIA;AACA;AzD4iKA;AyD1iKA;AACA;AACA;AACA;AACA;AACA;AALA;AzDkjKA;AACA;A0DnkKA;AACA;AACA;A1DqkKA;A0DlkKA;AACA;A1DokKA;AACA;A0DlkKA;AACA;AACA;AAIA;AACA;AACA;A1DikKA;A0D/jKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A1DikKA;A0D/jKA;AAAA;AAAA;AACA;A1DmkKA;A0DjkKA;AACA;AACA;AACA;AACA;AAJA;A1DwkKA;A2D1nKA;AACA;AACA;AACA;AACA;AACA;AACA;A3D4nKA;A2D1nKA;AACA;A3D4nKA;A2D1nKA;AACA;AACA;A3D4nKA;A2D1nKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A3D4nKA;A2D1nKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtCA;A3DmqKA;A4DnqKA;AACA;AACA;AACA;AACA;AACA;AACA;A5DqqKA;A4DnqKA;A5DqqKA;A4DnqKA;AACA;AAEA;AACA;AACA;AAfA;A5DorKA;A6DprKA;AACA;AACA;AACA;A7DsrKA;A6DprKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;A7DwrKA;A6DtrKA;AACA;AACA;A7DwrKA;A6DtrKA;AACA;AACA;A7DwrKA;A6DtrKA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;A7DwrKA;A6DtrKA;AACA;AACA;AACA;AAEA;AACA;A7DurKA;A6DrrKA;AACA;AACA;AACA;A7DurKA;A6DrrKA;A7DurKA;AACA;A6DrrKA;A7DurKA;AACA;A6DrrKA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;A7DsrKA;A6DprKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A7DmrKA;A6DjrKA;AACA;A7DmrKA;AACA;AACA;AACA;A6DjrKA;A7DmrKA;A6DjrKA;AACA;A7DmrKA;A6D/qKA;AACA;AAEA;AACA;A7DgrKA;A6D9qKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;A7DirKA;A6D/qKA;AACA;AACA;AACA;AACA;AACA;AALA;A7DurKA;A8D3zKA;AACA;AACA;AACA;AACA;AACA;AACA;A9D6zKA;A8D3zKA;A9D6zKA;A8D3zKA;AACA;AACA;AACA;A9D6zKA;A8D3zKA;AACA;AACA;A9D6zKA;A8D3zKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;A9D61KA;A+D71KA;AACA;AACA;AACA;AACA;AACA;AALA;A/Dq2KA;A+D71KA;AACA;A/D+1KA;A+D71KA;AACA;AACA;AACA;A/D+1KA;A+D71KA;AACA;A/D+1KA;AACA;AACA;A+D91KA;A/Dg2KA;AACA;A+D91KA;AACA;AACA;AAEA;A/D+1KA;A+D71KA;AACA;AACA;AACA;AACA;AACA;A/D+1KA;AgEj4KA;AACA;AACA;AACA;AACA;AACA;AACA;AhEm4KA;AgEj4KA;AACA;AhEm4KA;AgEj4KA;AACA;AACA;AhEm4KA;AgEj4KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AhEm4KA;AgEj4KA;AACA;AACA;AACA;AACA;AA7BA;AhEi6KA;AiEj6KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AjEm6KA;AACA;AACA;AACA;AiEj6KA;AACA;AjEm6KA;AiEj6KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AjEm6KA;AiEj6KA;AACA;AACA;AAEA;AACA;AjEk6KA;AiEh6KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AjEk6KA;AiEh6KA;AACA;AACA;AjEk6KA;AiEh6KA;AACA;AACA;AACA;AACA;AjEk6KA;AiEh6KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9EA;AjEi/KA;AkEj/KA;AACA;AACA;AACA;AACA;AACA;AACA;AlEm/KA;AkEj/KA;AACA;AACA;AACA;AACA;AACA;AlEm/KA;AkEj/KA;AACA;AAIA;AlEg/KA;AkE9+KA;AACA;AACA;AACA;AADA;AAGA;AAEA;AACA;AA9BA;AlE8gLA;AmE9gLA;AACA;AACA;AACA;AAHA;AnEohLA;AmE9gLA;AnEghLA;AACA;AACA;AmE9gLA;AnEghLA;AmE7gLA;AnE+gLA;AmE7gLA;AACA;AACA;AACA;AACA;AACA;AACA;AnE+gLA;AmE7gLA;AnE+gLA;AmE7gLA;AACA;AnE+gLA;AmE7gLA;AACA;AADA;AnEihLA;AmE7gLA;AACA;AACA;AACA;AACA;AACA;AACA;AnE+gLA;AACA;AmE7gLA;AACA;AACA;AACA;AACA;AACA;AACA;AAhCA;AnEgjLA;AmE7gLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAjCA;AnEgkLA;AoElnLA;AACA;AACA;AACA;AACA;AACA;AACA;ApEonLA;AoElnLA;AACA;AACA;AACA;AACA;ApEonLA;AoElnLA;ApEonLA;AoElnLA;AACA;AACA;AACA;AACA;ApEonLA;AoElnLA;AACA;AACA;AACA;ApEonLA;AoElnLA;AACA;AACA;AACA;AAhBA;ApEqoLA;AoElnLA;AACA;ApEonLA;AoElnLA;AACA;AACA;AACA;AACA;AACA;AACA;ApEonLA;AoElnLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;ApEmoLA;AACA;AoElnLA;AAEA;AACA;AACA;ApEmnLA;AACA;AoEjnLA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;ApE4mLA;AoE1mLA;AACA;AACA;AACA;AACA;ApE4mLA;AoE1mLA;AACA;AACA;AACA;AACA;AACA;AACA;ApE4mLA;AoE1mLA;ApE4mLA;AoE1mLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjJA;ApE8vLA;AqE9vLA;AACA;ArEgwLA;AqE9vLA;ArEgwLA;AACA;AqE9vLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArEgwLA;AqE9vLA;AACA;ArEgwLA;AqE9vLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArEgwLA;AACA;AqE9vLA;AACA;AACA;AACA;ArEgwLA;AqE9vLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArEgwLA;AACA;AqE9vLA;AACA;AACA;ArEgwLA;AqE9vLA;AACA;AACA;AACA;ArEgwLA;AqE9vLA;AACA;AACA;ArEgwLA;AACA;AqE9vLA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;ArEmwLA;AACA;AqE9vLA;AACA;AACA;ArEgwLA;AqE9vLA;ArEgwLA;AqE9vLA;ArEgwLA;AqE9vLA;AACA;ArEgwLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AACA;AACA;AqE7vLA;ArE+vLA;AqE7vLA;AACA;ArE+vLA;AACA;AqE7vLA;AACA;ArE+vLA;AqE7vLA;AACA;AACA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;ArE+vLA;AqE7vLA;AACA;AACA;ArE+vLA;AqE7vLA;AACA;AACA;AACA;ArE+vLA;AACA;AACA;AqE7vLA;AACA;ArE+vLA;AqEvvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArEyvLA;AqEvvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ArEyvLA;AqEvvLA;AACA;ArEyvLA;AqEvvLA;AACA;AACA;AACA;ArEyvLA;AqEvvLA;AACA;AACA;AACA;AACA;AACA;AALA;ArE+vLA;AsE//LA;AACA;AADA;AtEmgMA;AsE//LA;AACA;AACA;AACA;AACA;AACA;AACA;AtEigMA;AsE//LA;AtEigMA;AsE//LA;AtEigMA;AsE//LA;AACA;AACA;AACA;AtEigMA;AACA;AsE//LA;AACA;AACA;AACA;AACA;AtEigMA;AsE//LA;AtEigMA;AsE//LA;AACA;AACA;AACA;AACA;AACA;AACA;AtEigMA;AsE//LA;AACA;AACA;AACA;AtEigMA;AsE//LA;AtEigMA;AACA;AACA;AsE//LA;AAEA;AtEggMA;AsE9/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AtEggMA;AsE9/LA;AACA;AACA;AtEggMA;AsE9/LA;AACA;AAdA;AAgBA;AtEggMA;AsE9/LA;AACA;AAEA;AACA;AtE+/LA;AsE7/LA;AACA;AACA;AtE+/LA;AsE7/LA;AACA;AAEA;AACA;AACA;AACA;AtE8/LA;AsE5/LA;AACA;AAEA;AACA;AtE6/LA;AsE3/LA;AACA;AACA;AACA;AACA;AACA;AACA;AtE6/LA;AsE3/LA;AACA;AACA;AApGA;AtEkmMA;AuEtmMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AvEwmMA;AACA;AuEtmMA;AACA;AACA;AACA;AvEwmMA;AACA;AACA;AuEtmMA;AvEwmMA;AuEtmMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AvEwmMA;AuEtmMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AvEwmMA;AuEtmMA;AACA;AvEwmMA;AACA;AuEtmMA;AvEwmMA;AACA;AuEtmMA;AvEwmMA;AuEtmMA;AvEwmMA;AuEtmMA;AACA;AvEwmMA;AuEtmMA;AACA;AACA;AACA;AACA;AACA;AvEwmMA;AuEtmMA;AACA;AACA;AACA;AAxEA;AvEirMA;AwEjrMA;AACA;AACA;AACA;AACA;AACA;AACA;AxEmrMA;AwEjrMA;AACA;AACA;AACA;AACA;AACA;AxEmrMA;AwEjrMA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AAhCA;AxEmtMA;AyEntMA;AACA;AACA;AACA;AACA;AACA;AACA;AzEqtMA;AyEntMA;AACA;AzEqtMA;AyEntMA;AACA;AzEqtMA;AyEntMA;AACA;AACA;AAhBA;AzEsuMA;AACA;AACA;AACA;A0EtuMA;AACA;AACA;AACA;AACA;AACA;AACA;A1EwuMA;AACA;A0EtuMA;A1EwuMA;A0EtuMA;AACA;AACA;AACA;AACA;AANA;A1E+uMA;A0EtuMA;AACA;AACA;AACA;A1EwuMA;A0EtuMA;A1EwuMA;A0EtuMA;A1EwuMA;A0EtuMA;A1EwuMA;AACA;AACA;A0EtuMA;AACA;AAEA;A1EuuMA;A0EruMA;AACA;A1EuuMA;A0EruMA;A1EuuMA;A0EpuMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A1EquMA;A0EnuMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A1EquMA;A0EnuMA;AACA;AAEA;AACA;AACA;AACA;AA7EA","file":"qt.js","sourcesContent":["global.Qt = {\n  rgba: function(r,g,b,a) {\n    return \"rgba(\"\n      + Math.round(r * 255) + \",\"\n      + Math.round(g * 255) + \",\"\n      + Math.round(b * 255) + \",\"\n      + a + \")\";\n  },\n  openUrlExternally: function(url) {\n    page = window.open(url, '_blank');\n    page.focus();\n  },\n  // Load file, parse and construct as Component (.qml)\n  createComponent: function(name) {\n    if (name in engine.components)\n        return engine.components[name];\n\n    var nameIsUrl = name.indexOf(\"//\") >= 0 || name.indexOf(\":/\") >= 0; // e.g. // in protocol, or :/ in disk urls (D:/)\n\n    // Do not perform path lookups if name starts with @ sign.\n    // This is used when we load components from qmldir files\n    // because in that case we do not need any lookups.\n    if (name.length > 0 && name[0] == \"@\") {\n      nameIsUrl = true;\n      name = name.substr( 1,name.length-1 );\n    }\n\n    var file = nameIsUrl ? name : engine.$basePath + name;\n\n    var src = getUrlContents(file, true);\n    // if failed to load, and provided name is not direct url, try to load from dirs in importPathList()\n    if (src==false && !nameIsUrl) {\n      var moredirs = engine.importPathList();\n\n      for (var i=0; i<moredirs.length; i++) {\n        file = moredirs[i] + name;\n        src = getUrlContents(file, true);\n        if (src !== false) break;\n      }\n    }\n\n    // When createComponent failed to load content from all probable sources, it should return undefined.\n    if (src === false)\n      return undefined;\n\n    var tree = parseQML(src, file);\n\n    if (tree.$children.length !== 1)\n        console.error(\"A QML component must only contain one root element!\");\n\n    var component = new QMLComponent({ object: tree, context: _executionContext });\n    component.$basePath = engine.extractBasePath( file );\n    component.$imports = tree.$imports;\n    component.$file = file; // just for debugging\n\n    engine.loadImports( tree.$imports,component.$basePath );\n\n    engine.components[name] = component;\n    return component;\n  },\n\n  createQmlObject: function(src, parent, file) {\n        var tree = parseQML(src, file);\n\n        // Create and initialize objects\n\n        var component = new QMLComponent({ object: tree, parent: parent, context: _executionContext });\n\n        engine.loadImports( tree.$imports );\n\n        if (!file) file = Qt.resolvedUrl(\"createQmlObject_function\");\n        component.$basePath = engine.extractBasePath(file);\n        component.$imports = tree.$imports; // for later use\n        component.$file = file; // not just for debugging, but for basepath too, see above\n\n        var obj = component.createObject(parent);\n        obj.parent = parent;\n        parent.childrenChanged();\n\n        if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n          // We don't call those on first creation, as they will be called\n          // by the regular creation-procedures at the right time.\n          engine.$initializePropertyBindings();\n\n          engine.callCompletedSignals();\n        }\n\n        return obj;\n  },\n\n    // Returns url resolved relative to the URL of the caller.\n  // http://doc.qt.io/qt-5/qml-qtqml-qt.html#resolvedUrl-method\n  resolvedUrl: function(url)\n  {\n    if (!url || !url.substr) // url is not a string object\n      return url;\n\n    // Must check for cases: D:/, file://, http://, or slash at the beginning. \n    // This means the url is absolute => we have to skip processing (except removing dot segments).\n    if (url == \"\" || url.indexOf(\":/\") != -1 || url.indexOf(\"/\") == 0)\n      return engine.removeDotSegments( url );\n\n    // we have $basePath variable placed in context of \"current\" document\n    // this is done in construct() function\n\n    // let's go to the callers and inspect their arguments\n    // The 2-nd argument of the callers we hope is context object\n    // e.g. see calling signature of bindings and signals\n\n    var detectedBasePath = \"\";\n    var currentCaller = Qt.resolvedUrl.caller;\n    var maxcount = 10;\n    while (maxcount-- > 0 && currentCaller) {\n      if (currentCaller.arguments[1] && currentCaller.arguments[1][\"$basePath\"])\n      {\n        detectedBasePath = currentCaller.arguments[1][\"$basePath\"];\n        break;\n      }\n      currentCaller = currentCaller.caller;\n    }\n\n    return engine.removeDotSegments( detectedBasePath + url )\n  },\n\n  // Buttons masks\n  LeftButton: 1,\n  RightButton: 2,\n  MiddleButton: 4,\n  // Modifiers masks\n  NoModifier: 0,\n  ShiftModifier: 1,\n  ControlModifier: 2,\n  AltModifier: 4,\n  MetaModifier: 8,\n  KeypadModifier: 16, // Note: Not available in web\n  // Layout directions\n  LeftToRight: 0,\n  RightToLeft: 1,\n  // Orientations\n  Vertical: 0,\n  Horizontal: 1,\n  // Keys\n  Key_Escape: 27,\n  Key_Tab: 9,\n  Key_Backtab: 245,\n  Key_Backspace: 8,\n  Key_Return: 13,\n  Key_Enter: 13,\n  Key_Insert: 45,\n  Key_Delete: 46,\n  Key_Pause: 19,\n  Key_Print: 42,\n  Key_SysReq: 0,\n  Key_Clear: 12,\n  Key_Home: 36,\n  Key_End: 35,\n  Key_Left: 37,\n  Key_Up: 38,\n  Key_Right: 39,\n  Key_Down: 40,\n  Key_PageUp: 33,\n  Key_PageDown: 34,\n  Key_Shift: 16,\n  Key_Control: 17,\n  Key_Meta: 91,\n  Key_Alt: 18,\n  Key_AltGr: 0,\n  Key_CapsLock: 20,\n  Key_NumLock: 144,\n  Key_ScrollLock: 145,\n  Key_F1: 112, Key_F2: 113, Key_F3: 114, Key_F4: 115, Key_F5: 116, Key_F6: 117, Key_F7: 118, Key_F8: 119, Key_F9: 120, Key_F10: 121, Key_F11: 122, Key_F12: 123, Key_F13: 124, Key_F14: 125, Key_F15: 126, Key_F16: 127, Key_F17: 128, Key_F18: 129, Key_F19: 130, Key_F20: 131, Key_F21: 132, Key_F22: 133, Key_F23: 134, Key_F24: 135, Key_F25: 0, Key_F26: 0, Key_F27: 0, Key_F28: 0, Key_F29: 0, Key_F30: 0, Key_F31: 0, Key_F32: 0, Key_F33: 0, Key_F34: 0, Key_F35: 0,\n  Key_Super_L: 0,\n  Key_Super_R: 0,\n  Key_Menu: 0,\n  Key_Hyper_L: 0,\n  Key_Hyper_R: 0,\n  Key_Help: 6,\n  Key_Direction_L: 0,\n  Key_Direction_R: 0,\n  Key_Space: 32,\n  Key_Any:   32,\n  Key_Exclam: 161,\n  Key_QuoteDbl: 162,\n  Key_NumberSign: 163,\n  Key_Dollar: 164,\n  Key_Percent: 165,\n  Key_Ampersant: 166,\n  Key_Apostrophe: 222,\n  Key_ParenLeft: 168,\n  Key_ParenRight: 169,\n  Key_Asterisk: 170,\n  Key_Plus: 171,\n  Key_Comma: 188,\n  Key_Minus: 173,\n  Key_Period: 190,\n  Key_Slash: 191,\n  Key_0: 48, Key_1: 49, Key_2: 50, Key_3: 51, Key_4: 52, Key_5: 53, Key_6: 54, Key_7: 55, Key_8: 56, Key_9: 57,\n  Key_Colon: 58,\n  Key_Semicolon: 59,\n  Key_Less: 60,\n  Key_Equal: 61,\n  Key_Greater: 62,\n  Key_Question: 63,\n  Key_At: 64,\n  Key_A: 65, Key_B: 66, Key_C: 67, Key_D: 68, Key_E: 69, Key_F: 70, Key_G: 71, Key_H: 72, Key_I: 73, Key_J: 74, Key_K: 75, Key_L: 76, Key_M: 77, Key_N: 78, Key_O: 79, Key_P: 80, Key_Q: 81, Key_R: 82, Key_S: 83, Key_T: 84, Key_U: 85, Key_V: 86, Key_W: 87, Key_X: 88, Key_Y: 89, Key_Z: 90,\n  Key_BracketLeft: 219,\n  Key_Backslash: 220,\n  Key_BracketRight: 221,\n  Key_AsciiCircum: 160,\n  Key_Underscore: 167,\n  Key_QuoteLeft: 0,\n  Key_BraceLeft: 174,\n  Key_Bar: 172,\n  Key_BraceRight: 175,\n  Key_AsciiTilde: 176,\n  Key_Back: 0,\n  Key_Forward: 0,\n  Key_Stop: 0,\n  Key_VolumeDown: 182,\n  Key_VolumeUp: 183,\n  Key_VolumeMute: 181,\n  Key_multiply: 106,\n  Key_add: 107,\n  Key_substract: 109,\n  Key_divide: 111,\n  Key_News: 0,\n  Key_OfficeHome: 0,\n  Key_Option: 0,\n  Key_Paste: 0,\n  Key_Phone: 0,\n  Key_Calendar: 0,\n  Key_Reply: 0,\n  Key_Reload: 0,\n  Key_RotateWindows: 0,\n  Key_RotationPB: 0,\n  Key_RotationKB: 0,\n  Key_Save: 0,\n  Key_Send: 0,\n  Key_Spell: 0,\n  Key_SplitScreen: 0,\n  Key_Support: 0,\n  Key_TaskPane: 0,\n  Key_Terminal: 0,\n  Key_Tools: 0,\n  Key_Travel: 0,\n  Key_Video: 0,\n  Key_Word: 0,\n  Key_Xfer: 0,\n  Key_ZoomIn: 0,\n  Key_ZoomOut: 0,\n  Key_Away: 0,\n  Key_Messenger: 0,\n  Key_WebCam: 0,\n  Key_MailForward: 0,\n  Key_Pictures: 0,\n  Key_Music: 0,\n  Key_Battery: 0,\n  Key_Bluetooth: 0,\n  Key_WLAN: 0,\n  Key_UWB: 0,\n  Key_AudioForward: 0,\n  Key_AudioRepeat: 0,\n  Key_AudioRandomPlay: 0,\n  Key_Subtitle: 0,\n  Key_AudioCycleTrack: 0,\n  Key_Time: 0,\n  Key_Hibernate: 0,\n  Key_View: 0,\n  Key_TopMenu: 0,\n  Key_PowerDown: 0,\n  Key_Suspend: 0,\n  Key_ContrastAdjust: 0,\n  Key_MediaLast: 0,\n  Key_unknown: -1,\n  Key_Call: 0,\n  Key_Camera: 0,\n  Key_CameraFocus: 0,\n  Key_Context1: 0,\n  Key_Context2: 0,\n  Key_Context3: 0,\n  Key_Context4: 0,\n  Key_Flip: 0,\n  Key_Hangup: 0,\n  Key_No: 0,\n  Key_Select: 93,\n  Key_Yes: 0,\n  Key_ToggleCallHangup: 0,\n  Key_VoiceDial: 0,\n  Key_LastNumberRedial: 0,\n  Key_Execute: 43,\n  Key_Printer: 42,\n  Key_Play: 250,\n  Key_Sleep: 95,\n  Key_Zoom: 251,\n  Key_Cancel: 3,\n  // Align\n  AlignLeft: 0x0001,\n  AlignRight: 0x0002,\n  AlignHCenter: 0x0004,\n  AlignJustify: 0x0008,\n  AlignTop: 0x0020,\n  AlignBottom: 0x0040,\n  AlignVCenter: 0x0080,\n  AlignCenter: 0x0084,\n  AlignBaseline: 0x0100,\n  AlignAbsolute: 0x0010,\n  AlignLeading: 0x0001,\n  AlignTrailing: 0x0002,\n  AlignHorizontal_Mask: 0x001f,\n  AlignVertical_Mask: 0x01e0,\n  // Screen\n  PrimaryOrientation: 0,\n  PortraitOrientation: 1,\n  LandscapeOrientation: 2,\n  InvertedPortraitOrientation: 4,\n  InvertedLandscapeOrientation: 8,\n  // CursorShape\n  ArrowCursor: 0,\n  UpArrowCursor: 1,\n  CrossCursor: 2,\n  WaitCursor: 3,\n  IBeamCursor: 4,\n  SizeVerCursor: 5,\n  SizeHorCursor: 6,\n  SizeBDiagCursor: 7,\n  SizeFDiagCursor: 8,\n  SizeAllCursor: 9,\n  BlankCursor: 10,\n  SplitVCursor: 11,\n  SplitHCursor: 12,\n  PointingHandCursor: 13,\n  ForbiddenCursor: 14,\n  WhatsThisCursor: 15,\n  BusyCursor: 16,\n  OpenHandCursor: 17,\n  ClosedHandCursor: 18,\n  DragCopyCursor: 19,\n  DragMoveCursor: 20,\n  DragLinkCursor: 21,\n  LastCursor: 21, //DragLinkCursor,\n  BitmapCursor: 24,\n  CustomCursor: 25,\n  // ScrollBar Policy\n  ScrollBarAsNeeded: 0,\n  ScrollBarAlwaysOff: 1,\n  ScrollBarAlwaysOn: 2\n}\n","/**\n * Create QML binding.\n * @param {Variant} val Sourcecode or function representing the binding\n * @param {Array} tree Parser tree of the binding\n * @return {Object} Object representing the binding\n */\nglobal.QMLBinding = function(val, tree) {\n    // this.isFunction states whether the binding is a simple js statement or a function containing\n    // a return statement. We decide this on whether it is a code block or not. If it is, we require\n    // a return statement. If it is a code block it could though also be a object definition, so we\n    // need to check that as well (it is, if the content is labels).\n    // need to check that as well (it is, if the content is labels).\n    this.isFunction = tree && tree[0] == \"block\" && tree[1][0] && tree[1][0][0] !== \"label\";\n    this.src = val;\n}\n\nglobal.QMLBinding.prototype.toJSON = function() {\n    return {src: this.src,\n        deps: JSON.stringify(this.deps),\n        tree: JSON.stringify(this.tree) };\n}\n\n/**\n * Compile binding. Afterwards you may call binding.eval to evaluate.\n */\nQMLBinding.prototype.compile = function() {\n    this.eval = new Function('__executionObject', '__executionContext', \"_executionContext = __executionContext; with(__executionContext) with(__executionObject) \" + ( this.isFunction ? \"\" : \"return \" ) + this.src);\n}\n","/* @license\n\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\n  Copyright (c) 2013 Anton Kreuzkamp <akreuzkamp@web.de>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n      * Redistributions of source code must retain the above\n        copyright notice, this list of conditions and the following\n        disclaimer.\n\n      * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following\n        disclaimer in the documentation and/or other materials\n        provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n  SUCH DAMAGE.\n*/\n\nQMLMethod.prototype = new QMLBinding();\nfunction QMLMethod(src) {\n    this.src = src;\n}\n\n/**\n * Create an object representing a QML property definition.\n * @param {String} type The type of the property\n * @param {Array} value The default value of the property\n * @return {Object} Object representing the defintion\n */\nfunction QMLPropertyDefinition(type, value) {\n    this.type = type;\n    this.value = value;\n}\n\nfunction QMLAliasDefinition(objName, propName) {\n    this.objectName = objName;\n    this.propertyName = propName;\n}\n\n/**\n * Create an object representing a QML signal definition.\n * @param {Array} params The parameters the signal ships\n * @return {Object} Object representing the defintion\n */\nfunction QMLSignalDefinition(params) {\n    this.parameters = params;\n}\n\n/**\n * Create an object representing a group of QML properties (like anchors).\n * @return {Object} Object representing the group\n */\nfunction QMLMetaPropertyGroup() {}\n\n/**\n * Create an object representing a QML element.\n * @param {String} type The type of the element\n * @param {String} onProp The name of the property specified with the \"on\" keyword\n */\nfunction QMLMetaElement(type, onProp) {\n    this.$class = type;\n    this.$children = [];\n    this.$on = onProp;\n}\n\n// Convert parser tree to the format understood by engine\nfunction convertToEngine(tree) {\n\n    // Help logger\n    function amIn(str, tree) {\n        console.log(str);\n        if (tree) console.log(JSON.stringify(tree, null, \"  \"));\n    }\n\n    var walkers = {\n        \"toplevel\": function(imports, statement) {\n            var item = { $class: \"Component\" };\n            item.$imports = imports;\n            item.$children = [ walk(statement) ];\n            return item;\n        },\n        \"qmlelem\": function(elem, onProp, statements) {\n            var item = new QMLMetaElement(elem, onProp);\n\n            for (var i in statements) {\n                var statement = statements[i],\n                    name = statement[1],\n                    val = walk(statement);\n                switch (statement[0]) {\n                    case \"qmldefaultprop\":\n                        item.$defaultProperty = name;\n                    case \"qmlprop\":\n                    case \"qmlpropdef\":\n                    case \"qmlaliasdef\":\n                    case \"qmlmethod\":\n                    case \"qmlsignaldef\":\n                        item[name] = val;\n                        break;\n                    case \"qmlelem\":\n                        item.$children.push(val);\n                        break;\n                    case \"qmlobjdef\":\n                        // Create object to item\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\n                        item[name][statement[2]] = val;\n                        break;\n                    case \"qmlobj\":\n                        // Create object to item\n                        item[name] = item[name] || new QMLMetaPropertyGroup();\n                        for (var i in val)\n                            item[name][i] = val[i];\n                        break;\n                    default:\n                        console.log(\"Unknown statement\", statement);\n\n                }\n            }\n            // Make $children be either a single item or an array, if it's more than one\n            if (item.$children.length === 1)\n                item.$children = item.$children[0];\n\n            return item;\n        },\n        \"qmlprop\": function(name, tree, src) {\n            if (name == \"id\") {\n                // id property\n                return tree[1][1];\n            }\n            return bindout(tree, src);\n        },\n        \"qmlobjdef\": function(name, property, tree, src) {\n            return bindout(tree, src);\n        },\n        \"qmlobj\": function(elem, statements) {\n            var item = {};\n\n            for (var i in statements) {\n                var statement = statements[i],\n                    name = statement[1],\n                    val = walk(statement);\n                if (statement[0] == \"qmlprop\")\n                    item[name] = val;\n            }\n\n            return item;\n        },\n        \"qmlmethod\": function(name, tree, src) {\n            return new QMLMethod(src);\n        },\n        \"qmlpropdef\": function(name, type, tree, src) {\n            return new QMLPropertyDefinition(type, tree ? bindout(tree, src) : undefined);\n        },\n        \"qmlaliasdef\": function(name, objName, propName) {\n            return new QMLAliasDefinition(objName, propName);\n        },\n        \"qmlsignaldef\": function(name, params) {\n            return new QMLSignalDefinition(params);\n        },\n        \"qmldefaultprop\": function(tree) {\n            return walk(tree);\n        },\n        \"name\": function(src) {\n            if (src == \"true\" || src == \"false\")\n                return src == \"true\";\n            return new QMLBinding(src, [\"name\", src]);\n        },\n        \"num\": function(src) {\n            return +src;\n        },\n        \"string\": function(src) {\n            return String(src);\n        },\n        \"array\": function(tree, src) {\n            var a = [];\n            var isList = false;\n            var hasBinding = false;\n            for (var i in tree) {\n                var val = bindout(tree[i]);\n                a.push(val);\n\n                if (val instanceof QMLMetaElement)\n                    isList = true;\n                else if (val instanceof QMLBinding)\n                    hasBinding = true;\n            }\n\n            if (hasBinding) {\n                if (isList)\n                    throw new TypeError(\"An array may either contain bindings or Element definitions.\");\n                return new QMLBinding(src, tree);\n            }\n\n            return a;\n        }\n    };\n\n    function walk(tree) {\n        var type = tree[0];\n        var walker = walkers[type];\n        if (!walker) {\n            console.log(\"No walker for \" + type);\n            return;\n        } else {\n            return walker.apply(type, tree.slice(1));\n        }\n    }\n\n    return walk(tree);\n\n    // Try to bind out tree and return static variable instead of binding\n    function bindout(tree, binding) {\n        if (tree[0] === \"stat\") // We want to process the content of the statement\n            tree = tree[1];     // (but still handle the case, we get the content directly)\n        var type = tree[0];\n        var walker = walkers[type];\n        if (walker) {\n            return walker.apply(type, tree.slice(1));\n        } else {\n            return new QMLBinding(binding, tree);\n        }\n    }\n\n}\n\n// Function to parse qml and output tree expected by engine\nfunction parseQML(src, file) {\n    loadParser();\n    qmlweb_parse.nowParsingFile = file;\n    var parsetree = qmlweb_parse(src, qmlweb_parse.QmlDocument);\n    return convertToEngine(parsetree);\n}\n\nfunction loadParser() {\n  if (typeof qmlweb_parse !== 'undefined')\n    return;\n\n  console.log('Loading parser...');\n  var tags = document.getElementsByTagName('script');\n  for (let i in tags) {\n    if (tags[i].src && tags[i].src.indexOf('/qt.') !== -1) {\n      let src = tags[i].src.replace('/qt.', '/qmlweb.parser.');\n      // TODO: rewrite to async loading\n      let xhr = new XMLHttpRequest();\n      xhr.open('GET', src, false);\n      xhr.send(null);\n      if (xhr.status !== 200 && xhr.status !== 0) { // 0 if accessing with file://\n          throw new Error('Could not load QmlWeb parser!');\n      }\n      (new Function(xhr.responseText))();\n      return;\n    }\n  }\n}\n","/* @license\n\n  Copyright (c) 2011 Lauri Paimen <lauri@paimen.info>\n  Copyright (c) 2015 Pavel Vasev <pavel.vasev@gmail.com> - initial\n                     and working import implementation.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions\n  are met:\n\n      * Redistributions of source code must retain the above\n        copyright notice, this list of conditions and the following\n        disclaimer.\n\n      * Redistributions in binary form must reproduce the above\n        copyright notice, this list of conditions and the following\n        disclaimer in the documentation and/or other materials\n        provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AS IS AND ANY\n  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE\n  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n  OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR\n  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n  SUCH DAMAGE.\n*/\n\n\n/*\n * Misc classes for importing files.\n *\n * Currently the file contains a lot of unused code for future\n * purposes. Most of it can be rewritten as there is now Javascript parser\n * available.\n *\n * Exports:\n *\n * - getUrlContents(url) -- get URL contents. Returns contents or false in\n *   error.\n *\n * - Some other stuff not currently used/needed.\n *\n *\n */\n(function() {\n\n/**\n * Get URL contents. EXPORTED.\n * @param url {String} Url to fetch.\n * @param skipExceptions {bool} when turned on, ignore exeptions and return false. This feature is used by readQmlDir.\n * @private\n * @return {mixed} String of contents or false in errors.\n *\n * Q1: can someone provide use-case when we need caching here?\n * A1:\n * Q2: should errors be cached? (now they aren't)\n * A2:\n \n * Q3: split getUrlContents into: getUrlContents, getUrlContentsWithCaching, getUrlContentsWithoutErrors..\n */\ngetUrlContents = function (url, skipExceptions) {\n    if (typeof urlContentCache[url] == 'undefined') {\n      var xhr = new XMLHttpRequest();\n      xhr.open(\"GET\", url, false);\n\n      if (skipExceptions)\n        { try { xhr.send(null); } catch (e) { return false; } } /* it is OK to not have logging here, because DeveloperTools already will have red log record */\n      else\n        xhr.send(null);\n\n      if (xhr.status != 200 && xhr.status != 0) { // 0 if accessing with file://\n          console.log(\"Retrieving \" + url + \" failed: \" + xhr.responseText, xhr);\n          return false;\n      }\n      urlContentCache[url] = xhr.responseText;\n    }\n    return urlContentCache[url];\n}\nif (typeof global.urlContentCache == 'undefined')\n  global.urlContentCache = {};\n\n/**\n * Read qmldir spec file at directory. EXPORTED.\n * @param url Url of the directory\n * @return {Object} Object, where .internals lists qmldir internal references\n *                          and .externals lists qmldir external references.\n */\n\n/*  Note on how importing works.\n\n   * parseQML gives us `tree.$imports` variable, which contains information from `import` statements.\n\n   * After each call to parseQML, we call engine.loadImports(tree.$imports).\n     It in turn invokes readQmlDir() calls for each import, with respect to current component base path and engine.importPathList().\n\n   * We keep all component names from all qmldir files in global variable `engine.qmldir`.\n   \n   * In construct() function, we use `engine.qmldir` for component url lookup.\n\n   Reference import info: http://doc.qt.io/qt-5/qtqml-syntax-imports.html \n   Also please look at notes and TODO's in qtcore.js::loadImports() and qtcore.js::construct() methods.\n*/\n \nreadQmlDir = function (url) {\n    // in case 'url' is empty, do not attach \"/\"\n    // Q1: when this happen?\n    var qmldirFileUrl = url.length > 0 ? (url + \"/qmldir\") : \"qmldir\";\n\n    if (!qrc.includesFile(qmldirFileUrl))\n      qrc[qmldirFileUrl] = getUrlContents(qmldirFileUrl, true); // loading url contents with skipping errors\n    var qmldir = qrc[qmldirFileUrl],\n        lines,\n        line,\n        internals = {},\n        externals = {},\n        match,\n        i;\n\n    if (qmldir === false) {\n        return false;\n    }\n\n    // we have to check for \"://\" \n    // In that case, item path is meant to be absolute, and we have no need to prefix it with base url\n    function makeurl( path ) {\n       if (path.indexOf(\"://\") > 0) return path;\n       return url + \"/\" + path;\n    }\n\n    lines = qmldir.split(/\\r?\\n/);\n    for (i = 0; i < lines.length; i++) {\n        // trim\n        line = lines[i].replace(/^\\s+|\\s+$/g, \"\");\n        if (!line.length || line[0] == \"#\") {\n            // Empty line or comment\n            continue;\n        }\n        match = line.split(/\\s+/);\n        if (match.length == 2 || match.length == 3) {\n            if (match[0] == \"plugin\") {\n                console.log(url + \": qmldir plugins are not supported!\");\n            } else if (match[0] == \"internal\") {\n                internals[match[1]] = { url: makeurl( match[2] ) };\n            } else {\n                if (match.length == 2) {\n                    externals[match[0]] = { url: makeurl( match[1] ) };\n                } else {\n                    externals[match[0]] = { url: makeurl( match[2] ), version: match[1] };\n                }\n            }\n        } else {\n            console.log(url + \": unmatched: \" + line);\n        }\n    }\n    return {internals: internals, externals: externals};\n}\n\n})();\n","global.Easing = {\n  Linear: 1,\n  InQuad: 2,          OutQuad: 3,     InOutQuad: 4,           OutInQuad: 5,\n  InCubic: 6,         OutCubic: 7,    InOutCubic: 8,          OutInCubic: 9,\n  InQuart: 10,        OutQuart: 11,   InOutQuart: 12,         OutInQuart: 13,\n  InQuint: 14,        OutQuint: 15,   InOutQuint: 16,         OutInQuint: 17,\n  InSine: 18,         OutSine: 19,    InOutSine: 20,          OutInSine: 21,\n  InExpo: 22,         OutExpo: 23,    InOutExpo: 24,          OutInExpo: 25,\n  InCirc: 26,         OutCirc: 27,    InOutCirc: 28,          OutInCirc: 29,\n  InElastic: 30,      OutElastic: 31, InOutElastic: 32,       OutInElastic: 33,\n  InBack: 34,         OutBack: 35,    InOutBack: 36,          OutInBack: 37,\n  InBounce: 38,       OutBounce: 39,  InOutBounce: 40,        OutInBounce: 41\n}\n","global.Font = {\n  // Capitalization\n  MixedCase: \"none\",\n  AllUppercase: \"uppercase\",\n  AllLowercase: \"lowercase\",\n  SmallCaps: \"smallcaps\",\n  Capitalize: \"capitalize\",\n  // Weight\n  Light: \"lighter\",\n  Normal: \"normal\",\n  DemiBold: \"600\",\n  Bold: \"bold\",\n  Black: \"bolder\"\n}\n","global.qrc = {\n  includesFile: function(path) {\n    return typeof qrc[path] != 'undefined';\n  }\n};\n","/**\n * Creates and returns a signal with the parameters specified in @p params.\n *\n * @param params Array with the parameters of the signal. Each element has to be\n *               an object with the two properties \"type\" and \"name\" specifying\n *               the datatype of the parameter and its name. The type is\n *               currently ignored.\n * @param options Options that allow finetuning of the signal.\n */\nglobal.Signal = function Signal(params, options) {\n    options = options || {};\n    var connectedSlots = [];\n    var obj = options.obj\n\n    var signal = function() {\n        for (var i in connectedSlots)\n            try {\n                connectedSlots[i].slot.apply(connectedSlots[i].thisObj, arguments);\n            } catch(err) {\n                console.log(err.message);\n            }\n    };\n    signal.parameters = params || [];\n    signal.connect = function() {\n        if (arguments.length == 1)\n            connectedSlots.push({thisObj: global, slot: arguments[0]});\n        else if (typeof arguments[1] == 'string' || arguments[1] instanceof String) {\n            if (arguments[0].$tidyupList && arguments[0] !== obj)\n                arguments[0].$tidyupList.push(this);\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[0][arguments[1]]});\n        } else {\n            if (arguments[0].$tidyupList && (!obj || (arguments[0] !== obj && arguments[0] !== obj.$parent)))\n                arguments[0].$tidyupList.push(this);\n            connectedSlots.push({thisObj: arguments[0], slot: arguments[1]});\n        }\n\n        // Notify object of connect\n        if (options.obj && options.obj.$connectNotify) {\n            options.obj.$connectNotify(options);\n        }\n\n    }\n    signal.disconnect = function() {\n        // callType meaning: 1 = function  2 = string  3 = object with string method  4 = object with function\n\n        var callType = arguments.length == 1 ? (arguments[0] instanceof Function ? 1 : 2)\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 3 : 4;\n        for (var i = 0; i < connectedSlots.length; i++) {\n            var item = connectedSlots[i];\n            if ((callType == 1 && item.slot == arguments[0])\n                || (callType == 2 && item.thisObj == arguments[0])\n                || (callType == 3 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\n            ) {\n                if (item.thisObj)\n                    item.thisObj.$tidyupList.splice(item.thisObj.$tidyupList.indexOf(this), 1);\n                connectedSlots.splice(i, 1);\n                i--; // We have removed an item from the list so the indexes shifted one backwards\n            }\n        }\n\n        // Notify object of disconnect\n        if (options.obj && options.obj.$disconnectNotify) {\n            options.obj.$disconnectNotify(options);\n        }\n    }\n    signal.isConnected = function() {\n        var callType = arguments.length == 1 ? 1\n                       : (typeof arguments[1] == 'string' || arguments[1] instanceof String) ? 2 : 3;\n        for (var i in connectedSlots) {\n            var item = connectedSlots[i];\n            if ((callType == 1 && item.slot == arguments[0])\n                || (callType == 2 && item.thisObj == arguments[0] && item.slot == arguments[0][arguments[1]])\n                || (item.thisObj == arguments[0] && item.slot == arguments[1])\n            )\n                return true;\n        }\n        return false;\n    }\n    return signal;\n}\n\n","// Property that is currently beeing evaluated. Used to get the information\n// which property called the getter of a certain other property for\n// evaluation and is thus dependant on it.\nvar evaluatingProperty;\n\nvar _executionContext = null;\n\n// All object constructors\nvar constructors = {\n  'int': QMLInteger,\n  real: Number,\n  'double': Number,\n  string: String,\n  'bool': Boolean,\n  list: QMLList,\n  color: QMLColor,\n  'enum': Number,\n  url: String,\n  variant: QMLVariant,\n  'var': QMLVariant\n};\n\nconst modules = {\n  Main: constructors\n};\n\nconst dependants = {};\n\n// Helper. Adds a type to the constructor list\nglobal.registerGlobalQmlType = function (name, type) {\n  global[type.name]  = type;\n  constructors[name] = type;\n  modules.Main[name] = type;\n};\n\n// Helper. Register a type to a module\nglobal.registerQmlType = function(options) {\n  if (typeof options.baseClass === 'string') {\n    // TODO: Does not support version specification (yet?)\n    var baseModule, baseName;\n    const dot = options.baseClass.lastIndexOf('.');\n    if (dot === -1) {\n      baseModule = options.module;\n      baseName = options.baseClass;\n    } else {\n      baseModule = options.baseClass.substring(0, dot);\n      baseName = options.baseClass.substring(dot + 1);\n    }\n    const found = (modules[baseModule] || [])\n                    .filter(descr => descr.name === baseName);\n    if (found.length > 0) {\n      // Ok, we found our base class\n      options.baseClass = found[0].constructor;\n    } else {\n      // Base class not found, delay the loading\n      const baseId = [baseModule, baseName].join('.');\n      if (!dependants.hasOwnProperty(baseId)) {\n        dependants[baseId] = [];\n      }\n      dependants[baseId].push(options);\n      return;\n    }\n  }\n\n  if (options.global) {\n    registerGlobalQmlType(options.name, options.constructor);\n  } else {\n    var moduleDescriptor = {\n      name:        options.name,\n      versions:    options.versions,\n      constructor: options.constructor\n    };\n\n    if (typeof modules[options.module] == 'undefined')\n      modules[options.module] = [];\n    modules[options.module].push(moduleDescriptor);\n  }\n\n    if (typeof options.baseClass !== 'undefined') {\n      inherit(options.constructor, options.baseClass);\n    }\n\n  const id = [options.module, options.name].join('.');\n  if (dependants.hasOwnProperty(id)) {\n    dependants[id].forEach(opt => global.registerQmlType(opt));\n    dependants[id].length = 0;\n  }\n};\n\nglobal.getConstructor = function (moduleName, version, name) {\n  if (typeof modules[moduleName] != 'undefined') {\n    for (var i = 0 ; i < modules[moduleName].length ; ++i) {\n      var type = modules[moduleName][i];\n\n      if (type.name == name && type.versions.test(version))\n        return type.constructor;\n    }\n  }\n  return null;\n};\n\nglobal.collectConstructorsForModule = function (moduleName, version) {\n  var constructors = {};\n\n  if (typeof modules[moduleName] == 'undefined') {\n    console.warn(\"module `\" + moduleName + \"` not found\");\n    return constructors;\n  }\n  for (var i = 0 ; i < modules[moduleName].length ; ++i) {\n    var module = modules[moduleName][i];\n\n    if (module.versions.test(version)) {\n      constructors[module.name] = module.constructor;\n    }\n  }\n  return constructors;\n};\n\nglobal.mergeObjects = function (obj1, obj2) {\n  var mergedObject = {};\n\n  if (typeof obj1 != 'undefined' && obj1 != null) {\n    for (var key in obj1) { mergedObject[key] = obj1[key]; }\n  }\n  if (typeof obj2 != 'undefined' && obj2 != null) {\n    for (var key in obj2) { mergedObject[key] = obj2[key]; }\n  }\n  return mergedObject;\n}\n\nglobal.perContextConstructors = {};\n\nglobal.loadImports = function (self, imports) {\n  constructors = mergeObjects(modules.Main, null);\n  for (var i = 0 ; i < imports.length ; ++i) {\n    var moduleName = imports[i][1],\n        moduleVersion = imports[i][2],\n        moduleAlias = imports[i][3],\n        moduleConstructors = collectConstructorsForModule(moduleName, moduleVersion);\n\n    if (moduleAlias !== \"\")\n      constructors[moduleAlias] = mergeObjects(constructors[moduleAlias], moduleConstructors);\n    else\n      constructors = mergeObjects(constructors, moduleConstructors);\n  }\n  perContextConstructors[self.objectId] = constructors;\n}\n\nglobal.inherit = function(constructor, baseClass) {\n  var oldProto = constructor.prototype;\n  constructor.prototype = Object.create(baseClass.prototype);\n  Object.keys(oldProto).forEach(function(prop) {\n    constructor.prototype[prop] = oldProto[prop];\n  });\n  constructor.prototype.constructor = baseClass;\n}\n\nfunction callSuper(self, meta) {\n  meta.super = meta.super.prototype.constructor;\n  meta.super.call(self, meta);\n}\n\n/**\n * QML Object constructor.\n * @param {Object} meta Meta information about the object and the creation context\n * @return {Object} New qml object\n */\nfunction construct(meta) {\n    var item,\n        component;\n\n    if (meta.object.$class in constructors) {\n        meta.super = constructors[meta.object.$class];\n        item = new constructors[meta.object.$class](meta);\n        meta.super = undefined;\n    }\n    else {\n        // Load component from file. Please look at import.js for main notes.\n        // Actually, we have to use that order:\n        // 1) try to load component from current basePath\n        // 2) from importPathList\n        // 3) from directories in imports statements and then\n        // 4) from qmldir files\n        // Currently we support only 1,2 and 4 and use order: 4,1,2\n        // TODO: engine.qmldirs is global for all loaded components. That's not qml's original behaviour.\n        var qdirInfo = engine.qmldirs[meta.object.$class]; // Are we have info on that component in some imported qmldir files?\n        if (qdirInfo) {\n            // We have that component in some qmldir, load it from qmldir's url\n            component = Qt.createComponent( \"@\" + qdirInfo.url, meta.context);\n        }\n        else\n            component = Qt.createComponent(meta.object.$class + \".qml\", meta.context);\n\n        if (component) {\n            var item = component.createObject(meta.parent);\n\n            if (typeof item.dom != 'undefined')\n                item.dom.className += \" \" + meta.object.$class + (meta.object.id ? \" \" + meta.object.id : \"\");\n            var dProp; // Handle default properties\n        } else {\n            throw new Error(\"No constructor found for \" + meta.object.$class);\n        }\n    }\n\n    // id\n    if (meta.object.id)\n        meta.context[meta.object.id] = item;\n\n    // keep path in item for probale use it later in Qt.resolvedUrl\n    item.$context[\"$basePath\"] = engine.$basePath; //gut\n\n    // Apply properties (Bindings won't get evaluated, yet)\n    applyProperties(meta.object, item, item, item.$context);\n\n    return item;\n}\n\n/**\n * Create property getters and setters for object.\n * @param {Object} obj Object for which gsetters will be set\n * @param {String} propName Property name\n * @param {Object} [options] Options that allow finetuning of the property\n */\nfunction createProperty(type, obj, propName, options = {}) {\n    var prop = new QMLProperty(type, obj, propName);\n    var getter, setter;\n\n    obj[propName + \"Changed\"] = prop.changed;\n    obj.$properties[propName] = prop;\n    obj.$properties[propName].set(options.initialValue, QMLProperty.ReasonInit);\n    getter = function()       { return obj.$properties[propName].get(); };\n    if (!options.readOnly)\n      setter = function(newVal) { obj.$properties[propName].set(newVal, QMLProperty.ReasonUser); };\n    else {\n      setter = function(newVal) {\n        if (obj.$canEditReadOnlyProperties != true)\n          throw \"property '\" + propName + \"' has read only access\";\n        obj.$properties[propName].set(newVal, QMLProperty.ReasonUser);\n      }\n    }\n    setupGetterSetter(obj, propName, getter, setter);\n    if (obj.$isComponentRoot)\n        setupGetterSetter(obj.$context, propName, getter, setter);\n}\n\n/**\n * Set up simple getter function for property\n */\n\nfunction setupGetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    get: func,\n    configurable: true,\n    enumerable: true\n  });\n}\n\nfunction setupSetter(obj, propName, func) {\n  Object.defineProperty(obj, propName, {\n    set: func,\n    configurable: true,\n    enumerable: false\n  });\n}\n\nfunction setupGetterSetter(obj, propName, getter, setter) {\n  Object.defineProperty(obj, propName, {\n    get: getter,\n    set: setter,\n    configurable: true,\n    enumerable: false\n  });\n}\n\n/**\n * Apply properties from metaObject to item.\n * @param {Object} metaObject Source of properties\n * @param {Object} item Target of property apply\n * @param {Object} objectScope Scope in which properties should be evaluated\n * @param {Object} componentScope Component scope in which properties should be evaluated\n */\nfunction applyProperties(metaObject, item, objectScope, componentScope) {\n    var i;\n    objectScope = objectScope || item;\n    _executionContext = componentScope;\n    for (i in metaObject) {\n        var value = metaObject[i];\n        // skip global id's and internal values\n        if (i == \"id\" || i[0] == \"$\") {\n            continue;\n        }\n        // slots\n        if (i.indexOf(\"on\") == 0 && i[2].toUpperCase() == i[2]) {\n            var signalName =  i[2].toLowerCase() + i.slice(3);\n            if (!item[signalName]) {\n                console.warn(\"No signal called \" + signalName + \" found!\");\n                continue;\n            }\n            else if (typeof item[signalName].connect != 'function') {\n                console.warn(signalName + \" is not a signal!\");\n                continue;\n            }\n            if (!value.eval) {\n                var params = \"\";\n                for (var j in item[signalName].parameters) {\n                    params += j==0 ? \"\" : \", \";\n                    params += item[signalName].parameters[j].name;\n                }\n                value.src = \"(function(\" + params + \") { _executionContext = __executionContext;\" + value.src + \"})\";\n                value.isFunction = false;\n                value.compile();\n            }\n            item[signalName].connect(item, value.eval(objectScope, componentScope));\n            continue;\n        }\n\n        if (value instanceof Object) {\n            if (value instanceof QMLSignalDefinition) {\n                item[i] = Signal(value.parameters);\n                if (item.$isComponentRoot)\n                    componentScope[i] = item[i];\n                continue;\n            } else if (value instanceof QMLMethod) {\n                value.compile();\n                item[i] = value.eval(objectScope, componentScope);\n                if (item.$isComponentRoot)\n                    componentScope[i] = item[i];\n                continue;\n            } else if (value instanceof QMLAliasDefinition) {\n                // TODO: 1. Alias must be able to point to prop or id of local object,eg: property alias q: t\n                //       2. Alias may have same name as id it points to: property alias someid: someid\n                //       3. Alias proxy (or property proxy) to proxy prop access to selected incapsulated object. (think twice).\n                createProperty(\"alias\", item, i);\n                item.$properties[i].componentScope = componentScope;\n                item.$properties[i].val = value;\n                item.$properties[i].get = function() {\n                    var obj = this.componentScope[this.val.objectName];\n                    return this.val.propertyName ? obj.$properties[this.val.propertyName].get() : obj;\n                }\n                item.$properties[i].set = function(newVal, reason, objectScope, componentScope) {\n                    if (!this.val.propertyName)\n                        throw \"Cannot set alias property pointing to an QML object.\";\n                    this.componentScope[this.val.objectName].$properties[this.val.propertyName].set(newVal, reason, objectScope, componentScope);\n                }\n\n                if (value.propertyName) {\n                  var con = function(prop) {\n                    var obj = prop.componentScope[prop.val.objectName];\n                    if (!obj) {\n                      console.error(\"qtcore: target object \",prop.val.objectName,\" not found for alias \",prop );\n                    } else {\n                      var targetProp = obj.$properties[prop.val.propertyName];\n                      if (!targetProp) {\n                        console.error(\"qtcore: target property [\",prop.val.objectName,\"].\",prop.val.propertyName,\" not found for alias \",prop.name );\n                      } else {\n                        // targetProp.changed.connect( prop.changed );\n                        // it is not sufficient to connect to `changed` of source property\n                        // we have to propagate own changed to it too\n                        // seems the best way to do this is to make them identical?..\n                        // prop.changed = targetProp.changed;\n                        // obj[i + \"Changed\"] = prop.changed;\n                        // no. because those object might be destroyed later.\n                        ( function() {\n                          var loopWatchdog = false;\n                          targetProp.changed.connect( item, function() {\n                              if (loopWatchdog) return; loopWatchdog = true;\n                              prop.changed.apply( item,arguments );\n                              loopWatchdog = false;\n                          } );\n                          prop.changed.connect( obj, function() {\n                              if (loopWatchdog) return; loopWatchdog = true;\n                              targetProp.changed.apply( obj, arguments );\n                              loopWatchdog = false;\n                          } );\n                        } ) ();\n                      }\n                    }\n                  }\n                  engine.pendingOperations.push( [con,item.$properties[i]] );\n                }\n\n                continue;\n            } else if (value instanceof QMLPropertyDefinition) {\n                createProperty(value.type, item, i);\n                item.$properties[i].set(value.value, QMLProperty.ReasonInit, objectScope, componentScope);\n                continue;\n            } else if (item[i] && value instanceof QMLMetaPropertyGroup) {\n                // Apply properties one by one, otherwise apply at once\n                applyProperties(value, item[i], objectScope, componentScope);\n                continue;\n            }\n        }\n        if (item.$properties && i in item.$properties)\n            item.$properties[i].set(value, QMLProperty.ReasonInit, objectScope, componentScope);\n        else if (i in item)\n            item[i] = value;\n        else if (item.$setCustomData)\n            item.$setCustomData(i, value);\n        else\n            console.warn(\"Cannot assign to non-existent property \\\"\" + i + \"\\\". Ignoring assignment.\");\n    }\n    if (metaObject.$children && metaObject.$children.length !== 0) {\n        if (item.$defaultProperty)\n            item.$properties[item.$defaultProperty].set(metaObject.$children, QMLProperty.ReasonInit, objectScope, componentScope);\n        else\n            throw \"Cannot assign to unexistant default property\";\n    }\n    // We purposefully set the default property AFTER using it, in order to only have it applied for\n    // instanciations of this component, but not for its internal children\n    if (metaObject.$defaultProperty)\n        item.$defaultProperty = metaObject.$defaultProperty;\n}\n\n// ItemModel. EXPORTED.\nJSItemModel = function() {\n    this.roleNames = [];\n\n    this.setRoleNames = function(names) {\n        this.roleNames = names;\n    }\n\n    this.dataChanged = Signal([\n        {type:\"int\", name:\"startIndex\"},\n        {type:\"int\", name:\"endIndex\"}\n    ]);\n    this.rowsInserted = Signal([\n        {type:\"int\", name:\"startIndex\"},\n        {type:\"int\", name:\"endIndex\"}\n    ]);\n    this.rowsMoved = Signal([\n        {type:\"int\", name:\"sourceStartIndex\"},\n        {type:\"int\", name:\"sourceEndIndex\"},\n        {type:\"int\", name:\"destinationIndex\"}\n    ]);\n    this.rowsRemoved = Signal([\n        {type:\"int\", name:\"startIndex\"},\n        {type:\"int\", name:\"endIndex\"}\n    ]);\n    this.modelReset = Signal();\n}\n\n// -----------------------------------------------------------------------------\n// Stuff below defines QML things\n// -----------------------------------------------------------------------------\n\n// Helper\nfunction unboundMethod() {\n    console.log(\"Unbound method for\", this);\n}\n","global.addEventListener('load', function() {\n  var metaTags = document.getElementsByTagName('BODY');\n\n  for (var i = 0 ; i < metaTags.length ; ++i) {\n    var metaTag = metaTags[i];\n    var source  = metaTag.getAttribute('data-qml');\n\n    if (source != null) {\n      global.qmlEngine = new QMLEngine();\n      qmlEngine.loadFile(source);\n      qmlEngine.start();\n      break ;\n    }\n  }\n});\n","  global.importJavascriptInContext = function (jsData, $context) {\n    // TODO: pass more objects to the scope?\n    (new Function('jsData', '$context', `\n      with ($context) {\n        ${jsData.source}\n      }\n      ${jsData.exports.map(sym => `$context.${sym} = ${sym};`).join('')}\n    `))(jsData, $context);\n  }\n\n  global.jsparse = function (source) {\n    var obj = { exports: [], source: source };\n    loadParser();\n    var AST_Tree = qmlweb_parse(source, qmlweb_parse.JSResource);\n    var main_scope = AST_Tree[1];\n\n    for (var i = 0 ; i < main_scope.length ; ++i) {\n      var item = main_scope[i];\n\n      switch (item[0]) {\n        case \"var\":\n          obj.exports.push(item[1][0][0]);\n          break ;\n        case \"defun\":\n          obj.exports.push(item[1]);\n          break ;\n      }\n    }\n    return obj;\n  }\n","// TODO\nfunction QMLColor(val) {\n  if (typeof val === \"number\") {\n    // we assume it is int value and must be converted to css hex with padding\n    // http://stackoverflow.com/questions/57803/how-to-convert-decimal-to-hex-in-javascript\n    val = \"#\" + (Math.round(val) + 0x1000000).toString(16).substr(-6).toUpperCase();\n  } else {\n    if(typeof val === \"array\" && val.length >= 3) {\n      // array like [r,g,b] where r,g,b are in 0..1 range\n      var m = 255;\n      val = \"rgb(\" + Math.round(m * val[0]) + \",\" + Math.round(m * val[1]) + \",\" + Math.round(m * val[2]) + \")\";\n    }\n  }\n  return val;\n};\n","/*\n * - QMLEngine(element, options) -- Returns new qml engine object, for which:\n *   - loadFile(file) -- Load file to the engine (.qml or .qml.js atm)\n *   - start() -- start the engine/application\n *   - stop() -- stop the engine/application. Restarting is experimental.\n *   element is HTMLCanvasElement and options are for debugging.\n *   For further reference, see testpad and qml viewer applications.\n */\n\n// There can only be one running QMLEngine. This variable points to the currently running engine.\nvar engine = null;\n\n// QML engine. EXPORTED.\nQMLEngine = function (element, options) {\n//----------Public Members----------\n    this.fps = 60;\n    this.$interval = Math.floor(1000 / this.fps); // Math.floor, causes bugs to timing?\n    this.running = false;\n\n    // List of available Components\n    this.components = {};\n\n    this.rootElement = element;\n\n    // List of Component.completed signals\n    this.completedSignals = [];\n\n    // Current operation state of the engine (Idle, init, etc.)\n    this.operationState = 1;\n\n    // List of properties whose values are bindings. For internal use only.\n    this.bindedProperties = [];\n\n    // List of operations to perform later after init. For internal use only.\n    this.pendingOperations = [];\n\n    // Root object of the engine\n    this.rootObject = null;\n\n    // Base path of qml engine (used for resource loading)\n    this.$basePath = \"\";\n\n\n//----------Public Methods----------\n    // Start the engine\n    this.start = function()\n    {\n        engine = this;\n        var i;\n        if (this.operationState !== QMLOperationState.Running) {\n            this.operationState = QMLOperationState.Running;\n            tickerId = setInterval(tick, this.$interval);\n            for (i = 0; i < whenStart.length; i++) {\n                whenStart[i]();\n            }\n        }\n    }\n\n    // Stop the engine\n    this.stop = function()\n    {\n        var i;\n        if (this.operationState == QMLOperationState.Running) {\n            clearInterval(tickerId);\n            this.operationState = QMLOperationState.Idle;\n            for (i = 0; i < whenStop.length; i++) {\n                whenStop[i]();\n            }\n        }\n    }\n\n\n    this.ensureFileIsLoadedInQrc = function(file) {\n      if (!qrc.includesFile(file)) {\n        var src = getUrlContents(file);\n\n        if (src) {\n            loadParser();\n            console.log('Loading file [', file, ']');\n            qrc[file] = qmlweb_parse(src, qmlweb_parse.QMLDocument);\n        } else {\n            console.log('Can not load file [', file, ']');\n        }\n      }\n    }\n\n    this.extractBasePath = function( file ) {\n       var basePath = file.split(/[\\/\\\\]/); // work both in url (\"/\") and windows (\"\\\", from file://d:\\test\\) notation\n       basePath[basePath.length - 1] = \"\";\n       basePath = basePath.join(\"/\");\n       return basePath;\n    }\n    // Load file, parse and construct (.qml or .qml.js)\n    this.loadFile = function(file) {\n        var tree;\n\n        this.$basePath = this.extractBasePath(file);\n        this.ensureFileIsLoadedInQrc(file);\n        tree = convertToEngine(qrc[file]);\n        this.loadQMLTree(tree);\n    }\n\n    // parse and construct qml\n    this.loadQML = function(src, file) { // file is not required; only for debug purposes\n        this.loadQMLTree(parseQML(src, file));\n    }\n\n    this.loadQMLTree = function(tree, file) {\n        engine = this;\n        if (options.debugTree) {\n            options.debugTree(tree);\n        }\n\n        // Create and initialize objects\n        var component = new QMLComponent({ object: tree, parent: null });\n\n        this.loadImports( tree.$imports );\n        component.$basePath = engine.$basePath;\n        component.$imports = tree.$imports; // for later use\n        component.$file = file; // just for debugging\n\n        this.rootObject = component.createObject(null);\n        component.finalizeImports(this.rootContext());\n        this.$initializePropertyBindings();\n\n        this.start();\n\n        this.callCompletedSignals();\n    }\n\n    /** from http://docs.closure-library.googlecode.com/git/local_closure_goog_uri_uri.js.source.html\n     *\n     * Removes dot segments in given path component, as described in\n     * RFC 3986, section 5.2.4.\n     *\n     * @param {string} path A non-empty path component.\n     * @return {string} Path component with removed dot segments.\n     */\n    this.removeDotSegments = function(path) {\n        var leadingSlash = (path && path[0] == \"/\");   // path.startsWith('/'); -- startsWith seems to be undefined in some browsers\n        var segments = path.split('/');\n        var out = [];\n\n        for (var pos = 0; pos < segments.length; ) {\n            var segment = segments[pos++];\n\n            if (segment == '.') {\n                if (leadingSlash && pos == segments.length) {\n                    out.push('');\n                }\n            } else if (segment == '..') {\n                if (out.length > 1 || out.length == 1 && out[0] != '') {\n                    out.pop();\n                }\n                if (leadingSlash && pos == segments.length) {\n                    out.push('');\n                }\n            } else {\n                out.push(segment);\n                leadingSlash = true;\n            }\n        }\n\n        return out.join('/');\n    };\n\n    /*\n      engine.loadImports( imports, currentDir ) : performs loading of qmldir files from given qml import records.\n\n      Input:\n      * parameter `importsArray` - import statements. It is in parser notation, e.g. [import1, import2, ...] where each importN is also array: [\"qmlimport\",\"name\",version,as,isQualifiedName]\n      * parameter `currentFileDir` - base dir for imports lookup. It will be used together with importPathList()\n\n      Implicit input:\n      * engine object function `importPathList()` - list of urls bases used for qmldir files lookup\n\n      Additional implicit input/output:\n      * engine object variable `qmldirsContents` - used for caching, e.g. memory for previously loaded qmldir files\n\n      Output: \n      * engine object variable `qmldirs` - new records will be added there\n\n      Return value: \n      * nothing\n\n      Details:\n\n      For each of given import statements, loadImports \n      1. computes qmldir file location according to http://doc.qt.io/qt-5/qtqml-syntax-imports.html\n      2. calls `readQmlDir` for actual reading and parsing of qmldir file content\n      3. gets `external` declarations of that qmldir file and pushes them to `engine.qmldirs` hash.\n\n      `engine.qmldirs` is a hash of form: { componentName => componentFileUrl }\n      This hash then used by `qml.js::construct` method for computing component urls.\n\n      Notes:\n      1. This method is not suited for loading js imports. This may be done probably after answering to Q1 (below).\n      2. Please look for additional notes at readQmlDir function.\n\n      QNA\n      Q1: How and where in engine component names might be prefixed? E.g. names with dot inside: SomeModule.Component1\n      A1: Seems it doesn't matter. Seems we may just save name with dot-inside right to qmldirs, and it may be used by construct() seamlessly. Check it..\n\n      Q2: How we may access component object from here, to store qmldirs info in components logical scope, and not at engine scope?\n      A2: Probably, answer is in Component.js and in global.loadImports\n\n      TODO \n      * We have to keep output in component scope, not in engine scope.\n      * We have to add module \"as\"-names to component's names (which is possible after keeping imports in component scope).\n      * Determine how this stuff is related to `global.loadImports`\n      * Check A1\n      * Make a complete picture of what going in with imports, including Component.js own imports loading\n      * Note importJs method in import.js \n    */\n\n    this.loadImports = function(importsArray, currentFileDir) {\n        if (!this.qmldirsContents) this.qmldirsContents = { \"QtQuick\":{}, \"QtQuick.Controls\":{} }; // cache\n        // putting initial keys in qmldirsContents - is a hack. We should find a way to explain to qmlweb, is this built-in module or qmldir-style module.\n\n        if (!this.qmldirs) this.qmldirs = {};                 // resulting components lookup table\n\n        if (!importsArray || importsArray.length == 0) return;\n        if (!currentFileDir) currentFileDir = this.$basePath;     // use this.$basePath by default\n\n        for (var i=0; i<importsArray.length; i++) {\n            var entry = importsArray[i];\n\n            var name = entry[1];\n\n            var nameIsUrl = name.indexOf(\"//\") == 0 || name.indexOf(\"://\") >= 0;  // is it url to remote resource\n            var nameIsQualifiedModuleName = entry[4]; // e.g. QtQuick, QtQuick.Controls, etc\n            var nameIsDir = !nameIsQualifiedModuleName && !nameIsUrl; // local [relative] dir\n\n            if (nameIsDir) {\n                // resolve name from relative to full dir path\n                // we hope all dirs are relative\n                name = this.removeDotSegments( currentFileDir + name );\n                if (name[ name.length-1 ] == \"/\")\n                    name = name.substr( 0, name.length-1 ); // remove trailing slash as it required for `readQmlDir`\n            }\n            // TODO if nameIsDir, we have also to add `name` to importPathList() for current component...\n\n            // check if we have already loaded that qmldir file\n            if (this.qmldirsContents[ name ]) continue;\n\n            var content = false;\n            if (nameIsQualifiedModuleName && this.userAddedModulePaths && this.userAddedModulePaths[ name ]) {\n                // 1. we have qualified module and user had configured path for that module with this.addModulePath\n                content = readQmlDir( this.userAddedModulePaths[ name ] );\n            }\n            else if (nameIsUrl || nameIsDir)\n            {\n                // 2. direct load\n                // nameIsUrl => url do not need dirs\n                // nameIsDir => already computed full path above\n                content = readQmlDir( name );\n            }\n            else\n            {\n                // 3. qt-style lookup for qualified module\n                var probableDirs = [currentFileDir].concat( this.importPathList() )\n                var diredName = name.replace( /\\./g,\"/\" );\n\n                for (var k=0; k<probableDirs.length; k++) {\n                    var file = probableDirs[k] + diredName;\n                    content = readQmlDir( file );\n                    if (content) break;\n                }\n            }\n\n            if (!content) {\n                console.log(\"qmlengine::loadImports: cannot load qmldir file for import name=\",name );\n                // save blank info, meaning that we failed to load import\n                // this prevents repeated lookups\n                this.qmldirsContents[ name ] = {};\n\n               // NEW\n               // add that dir to import path list\n               // that means, lookup qml files in that failed dir by trying to load them directly\n               // this is not the same behavior as in Qt for \"url\" schemes,\n               // but it is same as for ordirnal disk files. \n               // So, we do it for experimental purposes.\n               if (nameIsDir) \n                 this.addImportPath( name + \"/\" );\n\n               continue;\n            }\n\n            // copy founded externals to global var\n            // TODO actually we have to copy it to current component\n            for (var attrname in content.externals) { this.qmldirs[attrname] = content.externals[attrname]; }\n\n            // keep already loaded qmldir files\n            this.qmldirsContents[ name ] = content;\n        }\n\n    }\n\n    this.rootContext = function() {\n      return this.rootObject.$context;\n    }\n\n    this.focusedElement = (function() {\n      return this.rootContext().activeFocus;\n    }).bind(this);\n\n    // KEYBOARD MANAGEMENT\n    var keyboardSignals = {};\n    keyboardSignals[Qt.Key_Asterisk]   = 'asteriskPressed';\n    keyboardSignals[Qt.Key_Back]       = 'backPressed';\n    keyboardSignals[Qt.Key_Backtab]    = 'backtabPressed';\n    keyboardSignals[Qt.Key_Call]       = 'callPressed';\n    keyboardSignals[Qt.Key_Cancel]     = 'cancelPressed';\n    keyboardSignals[Qt.Key_Delete]     = 'deletePressed';\n    keyboardSignals[Qt.Key_0]          = 'digit0Pressed';\n    keyboardSignals[Qt.Key_1]          = 'digit1Pressed';\n    keyboardSignals[Qt.Key_2]          = 'digit2Pressed';\n    keyboardSignals[Qt.Key_3]          = 'digit3Pressed';\n    keyboardSignals[Qt.Key_4]          = 'digit4Pressed';\n    keyboardSignals[Qt.Key_5]          = 'digit5Pressed';\n    keyboardSignals[Qt.Key_6]          = 'digit6Pressed';\n    keyboardSignals[Qt.Key_7]          = 'digit7Pressed';\n    keyboardSignals[Qt.Key_8]          = 'digit8Pressed';\n    keyboardSignals[Qt.Key_9]          = 'digit9Pressed';\n    keyboardSignals[Qt.Key_Escape]     = 'escapePressed';\n    keyboardSignals[Qt.Key_Flip]       = 'flipPressed';\n    keyboardSignals[Qt.Key_Hangup]     = 'hangupPressed';\n    keyboardSignals[Qt.Key_Menu]       = 'menuPressed';\n    keyboardSignals[Qt.Key_No]         = 'noPressed';\n    keyboardSignals[Qt.Key_Return]     = 'returnPressed';\n    keyboardSignals[Qt.Key_Select]     = 'selectPressed';\n    keyboardSignals[Qt.Key_Space]      = 'spacePressed';\n    keyboardSignals[Qt.Key_Tab]        = 'tabPressed';\n    keyboardSignals[Qt.Key_VolumeDown] = 'volumeDownPressed';\n    keyboardSignals[Qt.Key_VolumeUp]   = 'volumeUpPressed';\n    keyboardSignals[Qt.Key_Yes]        = 'yesPressed';\n    keyboardSignals[Qt.Key_Up]         = 'upPressed';\n    keyboardSignals[Qt.Key_Right]      = 'rightPressed';\n    keyboardSignals[Qt.Key_Down]       = 'downPressed';\n    keyboardSignals[Qt.Key_Left]       = 'leftPressed';\n\n    function keyCodeToQt(e) {\n      e.keypad = e.keyCode >= 96 && e.keyCode <= 111;\n      if (e.keyCode == Qt.Key_Tab && e.shiftKey == true)\n        return Qt.Key_Backtab;\n      else if (e.keyCode >= 97 && e.keyCode <= 122)\n        return e.keyCode - (97 - Qt.Key_A);\n      return e.keyCode;\n    }\n\n    function eventToKeyboard(e) {\n        return {\n            accepted: false,\n            count: 1,\n            isAutoRepeat: false,\n            key: keyCodeToQt(e),\n            modifiers: (e.ctrlKey * Qt.CtrlModifier)\n                    | (e.altKey   * Qt.AltModifier)\n                    | (e.shiftKey * Qt.ShiftModifier)\n                    | (e.metaKey  * Qt.MetaModifier)\n                    | (e.keypad   * Qt.KeypadModifier),\n            text: String.fromCharCode(e.charCode)\n        };\n    }\n\n    document.onkeypress = (function(e) {\n      var focusedElement = this.focusedElement();\n      var event          = eventToKeyboard(e || window.event);\n      var eventName      = keyboardSignals[event.key];\n\n      while (event.accepted != true && focusedElement != null) {\n        var backup       = focusedElement.$context.event;\n\n        focusedElement.$context.event = event;\n        focusedElement.Keys.pressed(event);\n        if (eventName != null)\n          focusedElement.Keys[eventName](event);\n        focusedElement.$context.event = backup;\n        if (event.accepted == true)\n          e.preventDefault();\n        else\n          focusedElement = focusedElement.$parent;\n      }\n    }).bind(this);\n\n    document.onkeyup = (function(e) {\n      var focusedElement = this.focusedElement();\n      var event          = eventToKeyboard(e || window.event);\n\n      while (event.accepted != true && focusedElement != null) {\n        var backup       = focusedElement.$context.event;\n\n        focusedElement.$context.event = event;\n        focusedElement.Keys.released(event);\n        focusedElement.$context.event = backup;\n        if (event.accepted == true)\n          e.preventDefault();\n        else\n          focusedElement = focusedElement.$parent;\n      }\n    }).bind(this);\n    // END KEYBOARD MANAGEMENT\n\n    this.registerProperty = function(obj, propName)\n    {\n        var dependantProperties = [];\n        var value = obj[propName];\n\n        function getter() {\n            if (evaluatingProperty && dependantProperties.indexOf(evaluatingProperty) == -1)\n                dependantProperties.push(evaluatingProperty);\n\n            return value;\n        }\n\n        function setter(newVal) {\n            value = newVal;\n\n            for (i in dependantProperties)\n                dependantProperties[i].update();\n        }\n\n        setupGetterSetter(obj, propName, getter, setter);\n    }\n\n    // next 3 methods used in Qt.createComponent for qml files lookup\n    // please open qt site for documentation\n    // http://doc.qt.io/qt-5/qqmlengine.html#addImportPath\n\n    this.addImportPath = function( dirpath ) {\n        if (!this.userAddedImportPaths) this.userAddedImportPaths = [];\n        this.userAddedImportPaths.push( dirpath );\n    }\n\n    this.setImportPathList = function( arrayOfDirs )\n    {\n        this.userAddedImportPaths = arrayOfDirs;\n    }\n\n    this.importPathList = function() {\n        return (this.userAddedImportPaths || []);\n    }\n\n    // `addModulePath` defines conrete path for module lookup\n    // e.g. addModulePath( \"QtQuick.Controls\",\"http://someserver.com/controls\" )\n    // will force system to `import QtQuick.Controls` module from `http://someserver.com/controls/qmldir`\n\n    this.addModulePath = function( moduleName, dirPath ) {\n\n        // remove trailing slash as it required for `readQmlDir`\n        if (dirPath[ dirPath.length-1 ] == \"/\")\n            dirPath = dirPath.substr( 0, dirPath.length-1 );\n\n        // keep the mapping. It will be used in loadImports() function .\n        if (!this.userAddedModulePaths) this.userAddedModulePaths = {};\n        this.userAddedModulePaths[ moduleName ] = dirPath;\n    }\n\n//Intern\n\n    // Load file, parse and construct as Component (.qml)\n    this.loadComponent = function(name)\n    {\n        if (name in this.components)\n            return this.components[name];\n\n        var file = engine.$basePath + name + \".qml\";\n\n        this.ensureFileIsLoadedInQrc(file);\n        tree = convertToEngine(qrc[file]);\n        this.components[name] = tree;\n        return tree;\n    }\n\n    this.$initializePropertyBindings = function() {\n        // Initialize property bindings\n        for (var i = 0; i < this.bindedProperties.length; i++) {\n            var property = this.bindedProperties[i];\n            if (!property.binding)\n              continue; // Probably, the binding was overwritten by an explicit value. Ignore.\n            property.binding.compile();\n            property.update();\n        }\n        this.bindedProperties = [];\n\n        this.$initializeAliasSignals();\n    }\n\n    this.$initializeAliasSignals = function() {\n        // Perform pending operations. Now we use it only to init alias's \"changed\" handlers, that's why we have such strange function name.\n        for (var i = 0; i < this.pendingOperations.length; i++) {\n            var op = this.pendingOperations[i];\n            op[0]( op[1] );\n        }\n        this.pendingOperations = [];\n    }\n\n    // Return a path to load the file\n    this.$resolvePath = function(file)\n    {\n        // probably, replace :// with :/ ?\n        if (file == \"\" || file.indexOf(\"://\") != -1 || file.indexOf(\"/\") == 0 || file.indexOf(\"data:\") == 0 || file.indexOf(\"blob:\") == 0) {\n            return file;\n        }\n        return this.$basePath + file;\n    }\n\n    this.$registerStart = function(f)\n    {\n        whenStart.push(f);\n    }\n\n    this.$registerStop = function(f)\n    {\n        whenStop.push(f);\n    }\n\n    this.$addTicker = function(t)\n    {\n        tickers.push(t);\n    }\n\n    this.$removeTicker = function(t)\n    {\n        var index = tickers.indexOf(t);\n        if (index != -1) {\n            tickers.splice(index, 1);\n        }\n    }\n\n    this.size = function()\n    {\n        return { width: this.rootObject.getWidth(), height: this.rootObject.getHeight() };\n    }\n\n//----------Private Methods----------\n\n    function tick()\n    {\n        var i,\n            now = (new Date).getTime(),\n            elapsed = now - lastTick;\n        lastTick = now;\n        for (i = 0; i < tickers.length; i++) {\n            tickers[i](now, elapsed);\n        }\n    }\n\n\n//----------Private Members----------\n    // Target canvas\n    var // Callbacks for stopping or starting the engine\n        whenStop = [],\n        whenStart = [],\n        // Ticker resource id and ticker callbacks\n        tickerId,\n        tickers = [],\n        lastTick = new Date().getTime(),\n        i;\n\n\n//----------Construct----------\n\n    options = options || {};\n\n    if (options.debugConsole) {\n        // Replace QML-side console.log\n        console = {};\n        console.log = function() {\n            var args = Array.prototype.slice.call(arguments);\n            options.debugConsole.apply(undefined, args);\n        };\n    }\n\n    // TODO: Move to module initialization\n    for (i in constructors) {\n        if (constructors[i].getAttachedObject)\n            setupGetter(QMLBaseObject.prototype, i, constructors[i].getAttachedObject);\n    }\n}\n\nQMLEngine.prototype.callCompletedSignals = function() {\n  // the while loop is better than for..in loop, because completedSignals array might change dynamically when\n  // some completed signal handlers will create objects dynamically via createQmlObject or Loader\n  while (this.completedSignals.length > 0) {\n     var handler = this.completedSignals.shift();\n     handler();\n  }\n};\n","function QMLInteger(val) {\n    return (val|0);\n}\n","function QMLList(meta) {\n    var list = [];\n    if (meta.object instanceof Array)\n        for (var i in meta.object)\n            list.push(construct({object: meta.object[i], parent: meta.parent, context: meta.context }));\n    else if (meta.object instanceof QMLMetaElement)\n        list.push(construct({object: meta.object, parent: meta.parent, context: meta.context }));\n\n    return list;\n}\n","QMLOperationState = {\n    Idle: 1,\n    Init: 2,\n    Running: 3\n};\n","function QMLProperty(type, obj, name) {\n    this.obj = obj;\n    this.name = name;\n    this.changed = Signal([], {obj:obj});\n    this.binding = null;\n    this.objectScope = null;\n    this.componentScope = null;\n    this.value = undefined;\n    this.type = type;\n    this.animation = null;\n\n    // This list contains all signals that hold references to this object.\n    // It is needed when deleting, as we need to tidy up all references to this object.\n    this.$tidyupList = [];\n}\n\nQMLProperty.ReasonUser = 0;\nQMLProperty.ReasonInit = 1;\nQMLProperty.ReasonAnimation = 2;\n\n// Updater recalculates the value of a property if one of the\n// dependencies changed\nQMLProperty.prototype.update = function() {\n    if (!this.binding)\n        return;\n\n    var oldVal = this.val;\n    evaluatingProperty = this;\n    this.val = this.binding.eval(this.objectScope, this.componentScope);\n    evaluatingProperty = undefined;\n\n    if (this.animation) {\n        this.animation.$actions = [{\n            target: this.animation.target || this.obj,\n            property: this.animation.property || this.name,\n            from: this.animation.from || oldVal,\n            to: this.animation.to || this.val\n        }];\n        this.animation.restart();\n    }\n\n    if (this.val !== oldVal)\n        this.changed(this.val, oldVal, this.name);\n}\n\n// Define getter\nQMLProperty.prototype.get = function() {\n    // If this call to the getter is due to a property that is dependant on this\n    // one, we need it to take track of changes\n    if (evaluatingProperty && !this.changed.isConnected(evaluatingProperty, QMLProperty.prototype.update))\n        this.changed.connect(evaluatingProperty, QMLProperty.prototype.update);\n\n    return this.val;\n}\n\nconst typeInitialValues = {\n  int: 0,\n  real: 0,\n  double: 0,\n  string: '',\n  bool: false,\n  list: [],\n  url: ''\n};\n\n// Define setter\nQMLProperty.prototype.set = function(newVal, reason, objectScope, componentScope) {\n    var i,\n        oldVal = this.val;\n\n    if (newVal instanceof QMLBinding) {\n        if (!objectScope || !componentScope)\n            throw \"Internal error: binding assigned without scope\";\n        this.binding = newVal;\n        this.objectScope = objectScope;\n        this.componentScope = componentScope;\n\n        if (engine.operationState !== QMLOperationState.Init) {\n            if (!newVal.eval)\n                newVal.compile();\n\n            evaluatingProperty = this;\n            newVal = this.binding.eval(objectScope, componentScope);\n            evaluatingProperty = null;\n        } else {\n            engine.bindedProperties.push(this);\n            return;\n        }\n    } else {\n        if (reason != QMLProperty.ReasonAnimation)\n            this.binding = null;\n        if (newVal instanceof Array)\n            newVal = newVal.slice(); // Copies the array\n    }\n\n    if (reason === QMLProperty.ReasonInit && typeof newVal === 'undefined') {\n      if (typeInitialValues.hasOwnProperty(this.type)) {\n        newVal = typeInitialValues[this.type];\n      }\n    }\n\n    if (constructors[this.type] == QMLList) {\n        this.val = QMLList({ object: newVal, parent: this.obj, context: componentScope });\n    } else if (newVal instanceof QMLMetaElement) {\n        if (constructors[newVal.$class] == QMLComponent || constructors[this.type] == QMLComponent)\n            this.val = new QMLComponent({ object: newVal, parent: this.obj, context: componentScope });\n        else\n            this.val = construct({ object: newVal, parent: this.obj, context: componentScope });\n    } else if (newVal instanceof Object || !newVal) {\n        this.val = newVal;\n    } else {\n        this.val = constructors[this.type](newVal);\n    }\n\n    if (this.val !== oldVal) {\n        if (this.animation && reason == QMLProperty.ReasonUser) {\n            this.animation.running = false;\n            this.animation.$actions = [{\n                target: this.animation.target || this.obj,\n                property: this.animation.property || this.name,\n                from: this.animation.from || oldVal,\n                to: this.animation.to || this.val\n            }];\n            this.animation.running = true;\n        }\n        if (this.obj.$syncPropertyToRemote instanceof Function && reason == QMLProperty.ReasonUser) { // is a remote object from e.g. a QWebChannel\n            this.obj.$syncPropertyToRemote(this.name, newVal);\n        } else {\n            this.changed(this.val, oldVal, this.name);\n        }\n    }\n}\n\n\n","function QMLVariant(val) {\n    return val;\n}\n","// Base object for all qml thingies\nvar objectIds = 0;\nfunction QObject(parent) {\n    this.$parent = parent;\n    if (parent && parent.$tidyupList)\n        parent.$tidyupList.push(this);\n    // List of things to tidy up when deleting this object.\n    this.$tidyupList = [];\n    this.$properties = {};\n\n    this.objectId = objectIds++;\n    this.$delete = function() {\n        if (this.$Component)\n          this.$Component.destruction();\n\n        while (this.$tidyupList.length > 0) {\n            var item = this.$tidyupList[0];\n            if (item.$delete) // It's a QObject\n                item.$delete();\n            else // It must be a signal\n                item.disconnect(this);\n        }\n\n        for (var i in this.$properties) {\n            var prop = this.$properties[i];\n            while (prop.$tidyupList.length > 0)\n                prop.$tidyupList[0].disconnect(prop);\n        }\n\n        if (this.$parent && this.$parent.$tidyupList)\n            this.$parent.$tidyupList.splice(this.$parent.$tidyupList.indexOf(this), 1);\n\n        // must do this:\n        // 1) parent will be notified and erase object from it's children.\n        // 2) DOM node will be removed.\n        this.parent = undefined;\n    }\n\n    // must have `destroy` method\n    // http://doc.qt.io/qt-5/qtqml-javascript-dynamicobjectcreation.html\n    this.destroy = this.$delete;\n}\n","function updateHGeometry(newVal, oldVal, propName) {\n    var anchors = this.anchors || this;\n    if (this.$updatingGeometry)\n        return;\n    this.$updatingGeometry = true;\n\n    var t, w, width, x, left, hC, right,\n        lM = anchors.leftMargin || anchors.margins,\n        rM = anchors.rightMargin || anchors.margins;\n\n    // Width\n    if (this.$isUsingImplicitWidth && propName == \"implicitWidth\")\n        width = this.implicitWidth;\n    else if (propName == \"width\")\n        this.$isUsingImplicitWidth = false;\n\n    // Position TODO: Layouts\n    if ((t = anchors.fill) !== undefined) {\n        if (!t.$properties.left.changed.isConnected(this, updateHGeometry))\n            t.$properties.left.changed.connect(this, updateHGeometry);\n        if (!t.$properties.width.changed.isConnected(this, updateHGeometry))\n            t.$properties.width.changed.connect(this, updateHGeometry);\n\n        this.$isUsingImplicitWidth = false;\n        width = t.width - lM - rM;\n        x = t.left - (this.parent ? this.parent.left : 0) + lM;\n        left = t.left + lM;\n        right = t.right - rM;\n        hC = (left + right) / 2;\n    } else if ((t = anchors.centerIn) !== undefined) {\n        if (!t.$properties.horizontalCenter.changed.isConnected(this, updateHGeometry))\n            t.$properties.horizontalCenter.changed.connect(this, updateHGeometry);\n\n        w = width || this.width;\n        hC = t.horizontalCenter;\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\n        left = hC - w / 2;\n        right = hC + w / 2;\n    } else if ((t = anchors.left) !== undefined) {\n        left = t + lM\n        if ((u = anchors.right) !== undefined) {\n            right = u - rM;\n            this.$isUsingImplicitWidth = false;\n            width = right - left;\n            x = left - (this.parent ? this.parent.left : 0);\n            hC = (right + left) / 2;\n        } else if ((hC = anchors.horizontalCenter) !== undefined) {\n            this.$isUsingImplicitWidth = false;\n            width = (hC - left) * 2;\n            x = left - (this.parent ? this.parent.left : 0);\n            right = 2 * hC - left;\n        } else {\n            w = width || this.width;\n            x = left - (this.parent ? this.parent.left : 0);\n            right = left + w;\n            hC = left + w / 2;\n        }\n    } else if ((t = anchors.right) !== undefined) {\n        right = t - rM;\n        if ((hC = anchors.horizontalCenter) !== undefined) {\n            this.$isUsingImplicitWidth = false;\n            width = (right - hC) * 2;\n            x = 2 * hC - right - (this.parent ? this.parent.left : 0);\n            left = 2 * hC - right;\n        } else {\n            w = width || this.width;\n            x = right - w - (this.parent ? this.parent.left : 0);\n            left = right - w;\n            hC = right - w / 2;\n        }\n    } else if ((hC = anchors.horizontalCenter) !== undefined) {\n        w = width || this.width;\n        x = hC - w / 2 - (this.parent ? this.parent.left : 0);\n        left = hC - w / 2;\n        right = hC + w / 2;\n    } else {\n        if (this.parent && !this.parent.$properties.left.changed.isConnected(this, updateHGeometry))\n            this.parent.$properties.left.changed.connect(this, updateHGeometry);\n\n        w = width || this.width;\n        left = this.x + (this.parent ? this.parent.left : 0);\n        right = left + w;\n        hC = left + w / 2;\n    }\n\n    if (left !== undefined)\n        this.left = left;\n    if (hC !== undefined)\n        this.horizontalCenter = hC;\n    if (right !== undefined)\n        this.right = right;\n    if (x !== undefined)\n        this.x = x;\n    if (width !== undefined)\n        this.width = width;\n\n    this.$updatingGeometry = false;\n\n    if (this.parent) updateChildrenRect(this.parent);\n}\n\nfunction updateVGeometry(newVal, oldVal, propName) {\n    var anchors = this.anchors || this;\n    if (this.$updatingGeometry)\n        return;\n    this.$updatingGeometry = true;\n\n    var t, w, height, y, top, vC, bottom,\n        tM = anchors.topMargin || anchors.margins,\n        bM = anchors.bottomMargin || anchors.margins;\n\n    // Height\n    if (this.$isUsingImplicitHeight && propName == \"implicitHeight\")\n        height = this.implicitHeight;\n    else if (propName == \"height\")\n        this.$isUsingImplicitHeight = false;\n\n    // Position TODO: Layouts\n    if ((t = anchors.fill) !== undefined) {\n        if (!t.$properties.top.changed.isConnected(this, updateVGeometry))\n            t.$properties.top.changed.connect(this, updateVGeometry);\n        if (!t.$properties.height.changed.isConnected(this, updateVGeometry))\n            t.$properties.height.changed.connect(this, updateVGeometry);\n\n        this.$isUsingImplicitHeight = false;\n        height = t.height - tM - bM;\n        y = t.top - (this.parent ? this.parent.top : 0) + tM;\n        top = t.top + tM;\n        bottom = t.bottom - bM;\n        vC = (top + bottom) / 2;\n    } else if ((t = anchors.centerIn) !== undefined) {\n        if (!t.$properties.verticalCenter.changed.isConnected(this, updateVGeometry))\n            t.$properties.verticalCenter.changed.connect(this, updateVGeometry);\n\n        w = height || this.height;\n        vC = t.verticalCenter;\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\n        top = vC - w / 2;\n        bottom = vC + w / 2;\n    } else if ((t = anchors.top) !== undefined) {\n        top = t + tM\n        if ((u = anchors.bottom) !== undefined) {\n            bottom = u - bM;\n            this.$isUsingImplicitHeight = false;\n            height = bottom - top;\n            y = top - (this.parent ? this.parent.top : 0);\n            vC = (bottom + top) / 2;\n        } else if ((vC = anchors.verticalCenter) !== undefined) {\n            this.$isUsingImplicitHeight = false;\n            height = (vC - top) * 2;\n            y = top - (this.parent ? this.parent.top : 0);\n            bottom = 2 * vC - top;\n        } else {\n            w = height || this.height;\n            y = top - (this.parent ? this.parent.top : 0);\n            bottom = top + w;\n            vC = top + w / 2;\n        }\n    } else if ((t = anchors.bottom) !== undefined) {\n        bottom = t - bM;\n        if ((vC = anchors.verticalCenter) !== undefined) {\n            this.$isUsingImplicitHeight = false;\n            height = (bottom - vC) * 2;\n            y = 2 * vC - bottom - (this.parent ? this.parent.top : 0);\n            top = 2 * vC - bottom;\n        } else {\n            w = height || this.height;\n            y = bottom - w - (this.parent ? this.parent.top : 0);\n            top = bottom - w;\n            vC = bottom - w / 2;\n        }\n    } else if ((vC = anchors.verticalCenter) !== undefined) {\n        w = height || this.height;\n        y = vC - w / 2 - (this.parent ? this.parent.top : 0);\n        top = vC - w / 2;\n        bottom = vC + w / 2;\n    } else {\n        if (this.parent && !this.parent.$properties.top.changed.isConnected(this, updateVGeometry))\n            this.parent.$properties.top.changed.connect(this, updateVGeometry);\n\n        w = height || this.height;\n        top = this.y + (this.parent ? this.parent.top : 0);\n        bottom = top + w;\n        vC = top + w / 2;\n    }\n\n    if (top !== undefined)\n        this.top = top;\n    if (vC !== undefined)\n        this.verticalCenter = vC;\n    if (bottom !== undefined)\n        this.bottom = bottom;\n    if (y !== undefined)\n        this.y = y;\n    if (height !== undefined)\n        this.height = height;\n\n    this.$updatingGeometry = false;\n\n    if (this.parent) updateChildrenRect(this.parent);\n}\n\nfunction updateChildrenRect(component) {\n    var children = component !== undefined ? component.children : undefined\n    if ( children == undefined || children.length == 0 )\n        return;\n\n    var maxWidth = 0;\n    var maxHeight = 0;\n    var minX = children.length>0 ? children[0].x : 0;\n    var minY = children.length>0 ? children[0].y : 0;\n    var child;\n\n    for (var i=0;i<children.length; i++){\n        child = children[i];\n        maxWidth = Math.max(maxWidth, child.x + child.width);\n        maxHeight = Math.max(maxHeight, child.y + child.heighth);\n        minX = Math.min(minX, child.x);\n        minY = Math.min(minX, child.y);\n    }\n\n    component.childrenRect.x = minX;\n    component.childrenRect.y = minY;\n    component.childrenRect.width = maxWidth;\n    component.childrenRect.height = maxHeight;\n}\n\n","function QMLDomElement(meta) {\n    callSuper(this, meta);\n    var tagName = meta.object.tagName || 'div';\n    this.dom = document.createElement(tagName);\n\n    createProperty('string', this, 'tagName');\n\n    // TODO: support properties, styles, perhaps changing the tagName\n}\n\nregisterQmlType({\n    module: 'QmlWeb.Dom',\n    name: 'DomElement',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLDomElement\n});\n","registerQmlType({\n  module:   'QmlWeb',\n  name:     'RestModel',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLRestModel(meta) {\n    callSuper(this, meta);\n    var self = this;\n    var attributes = this.getAttributes();\n\n    createProperty(\"string\", this, \"url\");\n    createProperty(\"bool\",   this, \"isLoading\");\n    createProperty(\"string\", this, \"mimeType\");\n    createProperty(\"string\", this, \"queryMimeType\");\n\n    this.mimeType      = \"application/json\";\n    this.queryMimeType = \"application/x-www-urlencoded\";\n    this.isLoading     = false;\n    this.attributes    = attributes;\n\n    this.fetched = Signal();\n    this.saved   = Signal();\n\n    this.runningRequests = 0;\n\n    this.fetch = function() {\n      ajax({\n        method:   'GET',\n        mimeType: self.mimetype,\n        success: function(xhr) {\n          xhrReadResponse(xhr);\n          self.fetched();\n        }\n      });\n    };\n\n    this.create = function() {\n      sendToServer('POST');\n    };\n\n    this.save = function() {\n      sendToServer('PUT');\n    };\n\n    function sendToServer(method) {\n      var body = generateBodyForPostQuery();\n\n      ajax({\n        method:   method,\n        mimeType: self.queryMimeType,\n        body:     body,\n        success:  function(xhr) {\n          xhrReadResponse(xhr);\n          self.saved();\n        }\n      });\n    }\n\n    this.remove = function() {\n      ajax({\n        method: 'DELETE',\n        success: function(xhr) {\n          self.destroy();\n        }\n      });\n    };\n\n    function generateBodyForPostQuery() {\n      var object     = {};\n      var body;\n\n      for (var i = 0 ; i < self.attributes.length ; ++i)\n        object[self.attributes[i]] = self.$properties[self.attributes[i]].get();\n      console.log(object);\n      if (self.queryMimeType == 'application/json' || self.queryMimeType == 'text/json')\n        body = JSON.stringify(object);\n      else if (self.queryMimeType == 'application/x-www-urlencoded')\n        body = objectToUrlEncoded(object);\n      return body;\n    }\n\n    function myEncodeURIComponent(str) {\n      return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {\n        return '%' + c.charCodeAt(0).toString(16);\n      });\n    }\n\n    function objectToUrlEncoded(object, prefix) {\n      var str = '';\n      for (var key in object) {\n        if (object.hasOwnProperty(key)) {\n          var value = object[key];\n          if (str != '')\n            str += '&';\n          if (typeof prefix != 'undefined')\n            key  = prefix + '[' + key + ']';\n          if (typeof value == 'object')\n            str += objectToUrlEncoded(value, key);\n          else\n            str += myEncodeURIComponent(key) + '=' + myEncodeURIComponent(value);\n        }\n      }\n      return str;\n    }\n\n    function ajax(options) {\n      var xhr = new XMLHttpRequest();\n\n      xhr.overrideMimeType(self.mimeType);\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState == XMLHttpRequest.DONE) {\n          if (xhr.status == 200)\n            options.success(xhr);\n          else\n            options.failure(xhr);\n          self.runningRequests -= 1;\n          if (self.runningRequests <= 0)\n            self.isLoading = false;\n        }\n      }\n      xhr.open(options.method, self.url, true);\n      if (typeof options.body != 'undefined') {\n        xhr.setRequestHeader('Content-Type', self.queryMimeType);\n        xhr.send(options.body);\n      }\n      else\n        xhr.send(null);\n      self.runningRequests += 1;\n      self.isLoading = true;\n    }\n\n    function xhrReadResponse(xhr) {\n      var responseObject;\n\n      if (self.mimeType == 'application/json' || self.mimeType == 'text/json') {\n        responseObject = JSON.parse(xhr.responseText);\n      }\n      updatePropertiesFromResponseObject(responseObject);\n    }\n\n    function updatePropertiesFromResponseObject(responseObject) {\n      for (var key in responseObject) {\n        if (responseObject.hasOwnProperty(key) && self.$hasProperty(key)) {\n          self.$properties[key].set(responseObject[key], QMLProperty.ReasonUser);\n        }\n      }\n    }\n\n    this.$hasProperty = function(name) {\n      return (typeof self.$properties[name] != 'undefined');\n    }\n  }\n});\n","registerQmlType({\n  module: 'Qt.labs.settings',\n  name:   'Settings',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLSettings(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"string\", this, \"category\");\n\n    if (typeof window.localStorage == 'undefined')\n      return ;\n\n    var attributes;\n\n    var getKey = (function(attrName) {\n      return this.category + '/' + attrName;\n    }).bind(this);\n\n    var loadProperties = (function() {\n      for (var i = 0 ; i < attributes.length ; ++i) {\n        this[attributes[i]] = localStorage.getItem(getKey(attributes[i]));\n      }\n    }).bind(this);\n\n    var initializeProperties = (function() {\n      for (var i = 0 ; i < attributes.length ; ++i) {\n        var attrName   = attributes[i];\n        var signalName = attrName + 'Changed';\n        var emitter    = this;\n\n        if (this.$properties[attrName].type == 'alias') {\n          emitter    = this.$context[this.$properties[attrName].val.objectName];\n          signalName = this.$properties[attrName].val.propertyName + 'Changed';\n        }\n        emitter[signalName].connect(this, (function() {\n          localStorage.setItem(getKey(this.attrName), this.self[this.attrName]);\n        }).bind({ self: this, attrName: attrName }));\n      }\n    }).bind(this);\n\n    this.Component.completed.connect(this, (function() {\n      attributes = this.getAttributes();\n      loadProperties();\n      initializeProperties();\n    }).bind(this));\n  }\n});\n","registerQmlType({\n  module:   'QtGraphicalEffects',\n  name:     'FastBlur',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLFastBlur(meta) {\n    callSuper(this, meta);\n\n    var previousSource = null;\n    var filterObject;\n\n    createProperty(\"real\", this, \"radius\");\n    createProperty(\"var\",  this, \"source\");\n    this.radius = 0;\n    this.source = null;\n\n    var updateFilterObject = (function() {\n      filterObject = {\n        transformType: 'filter',\n        operation:     'blur',\n        parameters:    this.radius + 'px'\n      };\n    }).bind(this);\n\n    function stripEffectFromSource(source) {\n      if (previousSource != null) {\n        var index = previousSource.transform.indexOf(filterObject);\n\n        previousSource.transform.splice(index, 1);\n        previousSource.$updateTransform();\n      }\n    }\n\n    function updateEffect(source) {\n      console.log(\"updating effect\");\n      stripEffectFromSource(previousSource);\n      if (source != null && typeof source.transform != 'undefined') {\n        updateFilterObject();\n        console.log(\"updating effect:\", filterObject, source);\n        source.transform.push(filterObject);\n        source.$updateTransform();\n        previousSource = source;\n      } else {\n        previousSource = null;\n      }\n    }\n\n    this.radiusChanged.connect(this, (function(newVal) {\n      updateEffect(this.source);\n    }).bind(this));\n\n    this.sourceChanged.connect(this, (function(newVal) {\n      updateEffect(this.source);\n    }).bind(this));\n  }\n});\n","registerQmlType({\n  module:   'QtMobility',\n  name:     'GeoLocation',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLGeoLocation(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    createProperty(\"double\", this, \"accuracy\");\n    createProperty(\"double\", this, \"altitude\");\n    createProperty(\"double\", this, \"altitudeAccuracy\");\n    createProperty(\"double\", this, \"heading\");\n    createProperty(\"string\", this, \"label\");\n    createProperty(\"double\", this, \"latitude\");\n    createProperty(\"double\", this, \"longitude\");\n    createProperty(\"double\", this, \"speed\");\n    createProperty(\"date\",   this, \"timestamp\");\n\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition\n    }\n\n    var updatePosition = (function(position) {\n      this.accuracy         = position.coords.accuracy;\n      this.altitude         = position.coords.altitude;\n      this.altitudeAccuracy = position.coords.altitudeAccuracy;\n      this.heading          = position.coords.heading;\n      this.latitude         = position.coords.latitude;\n      this.longitude        = position.coords.longitude;\n      this.speed            = position.coords.speed;\n      this.timestamp        = position.timestamp;\n    }).bind(this);\n\n    navigator.geolocation.getCurrentPosition(updatePosition);\n    navigator.geolocation.watchPosition(updatePosition);\n  }\n});\n","global.MediaPlayer = {\n  NoError: 0, ResourceError: 1, FormatError: 2, NetworkError: 4, AccessDenied: 8, ServiceMissing: 16,\n  StoppedState: 0, PlayingState: 1, PausedState: 2,\n  NoMedia: 0, Loading: 1, Loaded: 2, Buffering: 4, Stalled: 8, EndOfMedia: 16, InvalidMedia: 32, UnknownStatus: 64\n};\n\nglobal.VideoOutput = {\n  PreserveAspectFit: 0, PreserveAspectCrop: 1, Stretch: 2\n};\n\nregisterQmlType({\n  module: 'QtMultimedia',\n  name:   'Video',\n  versions: /^5\\./,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLVideo(meta) {\n    callSuper(this, meta);\n\n    var runningEventListener = 0;\n    var volumeBackup;\n\n    const domVideo = this.impl = document.createElement('video');\n    domVideo.style.width = domVideo.style.height = \"100%\";\n    domVideo.style.margin = \"0\";\n    this.dom.appendChild(domVideo);\n\n    createProperty(\"bool\",   this, \"autoPlay\");\n    createProperty(\"enum\",   this, \"fillMode\");\n    createProperty(\"int\",    this, \"duration\");\n    createProperty(\"int\",    this, \"position\");\n    createProperty(\"bool\",   this, \"muted\");\n    createProperty(\"real\",   this, \"playbackRate\");\n    createProperty(\"enum\",   this, \"playbackState\");\n    createProperty(\"string\", this, \"source\");\n    createProperty(\"real\",   this, \"volume\");\n    createProperty(\"enum\",   this, \"status\");\n    createProperty(\"enum\",   this, \"error\");\n    this.status = MediaPlayer.NoMedia;\n    this.error = MediaPlayer.NoError;\n    this.fillMode = VideoOutput.PreserveAspectFit;\n    this.volume = domVideo.volume;\n    this.duration = domVideo.duration;\n    this.playbackState = MediaPlayer.StoppedState;\n    this.muted = false;\n\n    this.paused  = Signal();\n    this.playing = Signal();\n    this.stopped = Signal();\n\n    this.autoPlayChanged.connect(this, (function(newVal) {\n      domVideo.autoplay = newVal;\n    }).bind(this));\n\n    domVideo.addEventListener(\"play\", (function() {\n      this.playing();\n      this.playbackState = MediaPlayer.PlayingState;\n    }).bind(this));\n\n    domVideo.addEventListener(\"pause\", (function() {\n      this.paused();\n      this.playbackState = MediaPlayer.PausedState;\n    }).bind(this));\n\n    domVideo.addEventListener(\"timeupdate\", (function() {\n      runningEventListener++;\n      this.position = domVideo.currentTime * 1000;\n      runningEventListener--;\n    }).bind(this));\n\n    domVideo.addEventListener(\"ended\", (function() {\n      this.stopped();\n      this.playbackState = MediaPlayer.StoppedState;\n    }).bind(this));\n\n    domVideo.addEventListener(\"progress\", (function() {\n      if (domVideo.buffered.length > 0) {\n        this.progress = domVideo.buffered.end(0) / domVideo.duration;\n        this.status   = this.progress < 1 ? MediaPlayer.Buffering : MediaPlayer.Buffered;\n      }\n    }).bind(this));\n\n    domVideo.addEventListener(\"stalled\", (function() {\n      this.status = MediaPlayer.Stalled;\n    }).bind(this));\n\n    domVideo.addEventListener(\"canplaythrough\", (function() {\n      this.status = MediaPlayer.Buffered;\n    }).bind(this));\n\n    domVideo.addEventListener(\"loadstart\", (function() {\n      this.status = MediaPlayer.Loading;\n    }).bind(this));\n\n    domVideo.addEventListener(\"durationchanged\", (function() {\n      this.duration = domVideo.duration;\n    }).bind(this));\n\n    domVideo.addEventListener(\"volumechanged\", (function() {\n      runningEventListener++;\n      this.volume = demoVideo.volume;\n      runningEventListener--;\n    }).bind(this));\n\n    domVideo.addEventListener(\"suspend\", (function() {\n      this.error |= MediaPlayer.NetworkError;\n    }).bind(this));\n\n    domVideo.addEventListener(\"error\", (function() {\n      this.error |= MediaPlayer.ResourceError;\n    }).bind(this));\n\n    domVideo.addEventListener(\"ratechange\", (function() {\n      runningEventListener++;\n      this.playbackRate = domVideo.playbackRate;\n      runningEventListener--;\n    }).bind(this));\n\n    this.pause = (function() {\n      domVideo.pause();\n    }).bind(this);\n\n    this.play = (function() {\n      domVideo.play();\n    }).bind(this);\n\n    this.seek = (function(offset) {\n      domVideo.currentTime = offset * 1000;\n    }).bind(this);\n\n    this.stop = (function() {\n    }).bind(this);\n\n    this.mimetypeFromExtension = function(extension) {\n      var mimetypes = {\n        ogg: 'video/ogg',\n        ogv: 'video/ogg',\n        ogm: 'video/ogg',\n        mp4: 'video/mp4',\n        webm: 'video/webm'\n      };\n\n      if (typeof mimetypes[extension] == 'undefined')\n        return \"\";\n      return mimetypes[extension];\n    };\n\n    this.sourceChanged.connect(this, (function(source) {\n      var parts     = source.split('.');\n      var extension = parts[parts.length - 1];\n\n      domVideo.src = source;\n      if (domVideo.canPlayType(this.mimetypeFromExtension(extension.toLowerCase())) == \"\")\n        this.error |= MediaPlayer.FormatError;\n    }).bind(this));\n\n    this.positionChanged.connect(this, (function(currentTime) {\n      if (runningEventListener == 0)\n        domVideo.currentTime = currentTime / 1000;\n    }).bind(this));\n\n    this.volumeChanged.connect(this, (function(volume) {\n      if (runningEventListener == 0)\n        domVideo.volume = volume;\n    }).bind(this));\n\n    this.playbackRateChanged.connect(this, (function(playbackRate) {\n      if (runningEventListener == 0)\n        domVideo.playbackRate = playbackRate;\n    }).bind(this));\n\n    this.mutedChanged.connect(this, (function(newValue) {\n      if (newValue == true) {\n        volulmeBackup = domVideo.volume;\n        this.volume = 0;\n      } else {\n        this.volume = volumeBackup;\n      }\n    }).bind(this));\n\n    this.fillModeChanged.connect(this, (function(newValue) {\n      switch (newValue) {\n        case VideoOutput.Stretch:\n          domVideo.style.objectFit = 'fill';\n          break ;\n        case VideoOutput.PreserveAspectFit:\n          domVideo.style.objectFit = '';\n          break ;\n        case VideoOutput.PreserveAspectCrop:\n          domVideo.style.objectFit = 'cover';\n          break ;\n      }\n    }).bind(this));\n  }\n});\n","function QMLContext() {\n    this.nameForObject = function(obj) {\n        for (var name in this) {\n            if (this[name] == obj)\n                return name;\n        }\n    }\n}\n\nQMLComponent.getAttachedObject = function() { // static\n    if (!this.$Component) {\n        this.$Component = new QObject(this);\n        this.$Component.completed = Signal([]);\n        engine.completedSignals.push(this.$Component.completed);\n\n        this.$Component.destruction = Signal([]);\n    }\n    return this.$Component;\n}\n\nQMLComponent.prototype.createObject = function(parent, properties) {\n    var oldState = engine.operationState;\n    engine.operationState = QMLOperationState.Init;\n    // change base path to current component base path\n    var bp = engine.$basePath; engine.$basePath = this.$basePath ? this.$basePath : engine.$basePath;\n\n    var item = construct({\n        object: this.$metaObject,\n        parent: parent,\n        context: this.$context ? Object.create(this.$context) : new QMLContext(),\n        isComponentRoot: true\n    });\n\n    // change base path back\n    //TODO looks a bit hacky\n    engine.$basePath = bp;\n\n    engine.operationState = oldState;\n    return item;\n}\n\nfunction QMLComponent(meta) {\n    if (constructors[meta.object.$class] == QMLComponent)\n        this.$metaObject = meta.object.$children[0];\n    else\n        this.$metaObject = meta.object;\n    this.$context = meta.context;\n\n    var jsImports = [];\n\n    this.finalizeImports = (function($context) {\n      for (var i = 0 ; i < jsImports.length ; ++i) {\n        var importDesc = jsImports[i];\n        var src = importDesc[1];\n        var js;\n\n        if (typeof engine.$basePath != 'undefined')\n          src = engine.$basePath + src;\n        if (typeof qrc[src] != 'undefined')\n          js = qrc[src];\n        else\n          js = global.jsparse(getUrlContents(src));\n        if (importDesc[3] !== \"\") {\n          $context[importDesc[3]] = {};\n          importJavascriptInContext(js, $context[importDesc[3]]);\n        }\n        else\n          importJavascriptInContext(js, $context);\n      }\n    }).bind(this);\n\n    if (meta.object.$imports instanceof Array)\n    {\n      var moduleImports = [];\n      var loadImport    = (function(importDesc) {\n        if (/\\.js$/.test(importDesc[1]))\n          jsImports.push(importDesc);\n        else\n          moduleImports.push(importDesc);\n      }).bind(this);\n\n      for (var i = 0 ; i < meta.object.$imports.length ; ++i) {\n        loadImport(meta.object.$imports[i]);\n      }\n      loadImports(this, moduleImports);\n      if (typeof this.$context != 'undefined' && this.$context != null)\n        this.finalizeImports(this.$context);\n    }\n}\n\nregisterQmlType({\n  global: true,\n  module: 'QtQml',\n  name: 'Component',\n  versions: /.*/,\n  baseClass: 'QtQuick.QtObject',\n  constructor: QMLComponent\n});\n","function QMLButton(meta) {\n    callSuper(this, meta);\n\n    const button = this.impl = document.createElement('button');\n    button.style.pointerEvents = 'auto';\n    this.dom.appendChild(button);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"bool\", this, \"enabled\", {initialValue: true});\n    this.clicked = Signal();\n\n    this.Component.completed.connect(this, function() {\n        this.implicitWidth = button.offsetWidth;\n        this.implicitHeight = button.offsetHeight;\n    });\n    this.textChanged.connect(this, function(newVal) {\n        button.textContent = newVal;\n        //TODO: Replace those statically sized borders\n        this.implicitWidth = button.offsetWidth;\n        this.implicitHeight = button.offsetHeight;\n    });\n    this.enabledChanged.connect(this, function(newVal) {\n        button.disabled = !newVal;\n    });\n\n    button.onclick = () => {\n        this.clicked();\n    }\n}\n\nregisterQmlType({\n  module: 'QtQuick.Controls',\n  name: 'Button',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: QMLButton\n});\n","registerQmlType({\n  module:   'QtQuick.Controls',\n  name:     'CheckBox',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: function QMLCheckbox(meta) {\n    callSuper(this, meta);\n\n    const label = this.impl = document.createElement('label');\n    label.style.pointerEvents = 'auto';\n\n    const checkbox = document.createElement('input');\n    checkbox.type = 'checkbox';\n    checkbox.style.verticalAlign = 'text-bottom';\n    label.appendChild(checkbox);\n\n    const span = document.createElement('span');\n    label.appendChild(span);\n\n    this.dom.appendChild(label);\n\n    var self = this;\n\n    var QMLFont = new getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"bool\", this, \"checked\");\n    createProperty(\"color\", this, \"color\");\n\n    this.Component.completed.connect(this, function() {\n        this.implicitHeight = label.offsetHeight;\n        this.implicitWidth = label.offsetWidth > 0 ? label.offsetWidth + 4 : 0;\n    });\n    this.textChanged.connect(this, function(newVal) {\n        span.innerHTML = newVal;\n        this.implicitHeight = label.offsetHeight;\n        this.implicitWidth = label.offsetWidth > 0 ? label.offsetWidth + 4 : 0;\n    });\n    this.colorChanged.connect(this, function(newVal) {\n        span.style.color = QMLColor(newVal);\n    });\n\n    this.checkedChanged.connect(this, function(newVal) {\n        checkbox.checked = self.checked;\n    });\n\n    checkbox.onchange = function() {\n        self.checked = this.checked;\n    };\n  }\n});\n","registerQmlType({\n    module: 'QtQuick.Controls',\n    name: 'ComboBox',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLComboBox\n});\n\nfunction QMLComboBox(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    this.dom.style.pointerEvents = \"auto\";\n    this.name = \"QMLComboBox\";\n\n    createProperty(\"int\", this, \"count\");\n    createProperty(\"int\", this, \"currentIndex\");\n    createProperty(\"string\", this, \"currentText\");\n    createProperty(\"array\", this, \"menu\");\n    createProperty(\"array\", this, \"model\");\n    createProperty(\"bool\", this, \"pressed\");\n\n    this.count = 0;\n    this.currentIndex = 0;\n    this.currentText = \"\";\n    this.menu = [];\n    this.model = [];\n    this.pressed = false;\n\n    var updateCB = function(){\n        var head = \"<select>\";\n        var tail = \"</select>\";\n        var html = head;\n\n        var model = self.model;\n        var count = model.length;\n        self.count = count;\n\n        for (var i = 0; i < count; i++) {\n            var elt = model[i];\n            //if (elt instanceof Array) { // TODO - optgroups? update model !\n            //    var count_i = elt.length;\n            //    for (var j = 0; j < count_i; j++)\n            //        html += \"<option>\" + elt[j] + \"</option>\";\n            //}\n            //else\n            html += \"<option>\" + elt + \"</option>\";\n        }\n        html += tail;\n        return html;\n    };\n\n    this.accepted = Signal();\n    this.activated = Signal([{type: \"int\", name: \"index\"}]);\n\n    this.find = function(text) {\n        return self.model.indexOf(text)\n    };\n    this.selectAll = function () {};    // TODO\n    this.textAt = function(index) {\n        return this.model[index];\n    };\n\n    this.Component.completed.connect(this, function () {\n        this.dom.innerHTML = updateCB();\n        var child = this.dom.firstChild;\n        this.implicitWidth = child.offsetWidth;\n        this.implicitHeight = child.offsetHeight;\n    });\n\n    this.modelChanged.connect(updateCB);\n\n    this.dom.onclick = function (e) {\n        var index = self.dom.firstChild.selectedIndex;\n        self.currentIndex = index ;\n        self.currentText = self.model[index];\n        self.accepted();\n        self.activated(index);\n    };\n}\n","function QMLScrollView(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    this.css.pointerEvents = \"auto\";\n    this.setupFocusOnDom(this.dom);\n\n    createProperty(\"Item\", this, \"contentItem\");\n    this.$defaultProperty = \"contentItem\";\n    createProperty(\"Item\", this, \"flickableItem\"); //TODO  0) implement it  1) make it read-only\n    createProperty(\"Item\", this, \"viewport\"); //TODO\n    createProperty(\"bool\", this, \"frameVisible\");\n    createProperty(\"bool\", this, \"highlightOnFocus\"); //TODO test\n    createProperty(\"enum\", this, \"verticalScrollBarPolicy\");\n    createProperty(\"enum\", this, \"horizontalScrollBarPolicy\");\n    createProperty(\"Component\", this, \"style\"); //TODO\n\n    this.contentItemChanged.connect(this, function(newItem){\n        if (typeof newItem !== undefined) {\n            newItem.parent = self;\n        }\n    });\n    this.flickableItemChanged.connect(this, function(newItem) {\n    });\n    this.viewportChanged.connect(this, function(newViewport) {\n    });\n    this.frameVisibleChanged.connect(this, function(visible) {\n        this.css.border= visible ? \"1px solid gray\" : \"hidden\";\n    });\n    this.highlightOnFocusChanged.connect(this, function(highlight) {\n    });\n\n    this.horizontalScrollBarPolicyChanged.connect(this, function(newPolicy) {\n        this.css.overflowX = this.scrollBarPolicyToCssOverflow(newPolicy);\n    });\n    this.verticalScrollBarPolicyChanged.connect(this, function(newPolicy) {\n        this.css.overflowY = this.scrollBarPolicyToCssOverflow(newPolicy);\n    });\n\n    this.styleChanged.connect(this, function(newStyle){});\n\n    ////\n    this.childrenChanged.connect(this, function(){\n       if (typeof self.contentItem == undefined && self.children.length == 1) {\n           self.contentItem = self.children[0];\n       }\n    });\n    this.focusChanged.connect(this, function(focus){\n        this.css.outline = self.highlight && focus ? \"outline: lightblue solid 2px;\" : \"\";\n    });\n\n    this.width = this.implicitWidth = 240; // default QML ScrollView width\n    this.height = this.implicitHeight = 150; // default QML ScrollView height\n    this.width = this.implicitWidth;\n    this.height = this.implicitHeight;\n\n    this.contentItem = undefined;\n    this.flickableItem = undefined;\n    this.viewport = undefined;\n    this.frameVisible = false;\n    this.highlightOnFocus = false;\n    this.verticalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.horizontalScrollBarPolicy = Qt.ScrollBarAsNeeded;\n    this.style = undefined;\n}\n\nQMLScrollView.prototype.scrollBarPolicyToCssOverflow = function(policy) {\n    switch (newPolicy) {\n        case Qt.ScrollBarAsNeeded:\n            return 'auto';\n        case Qt.ScrollBarAlwaysOff:\n            return 'hidden';\n        case Qt.ScrollBarAlwaysOn:\n            return 'scroll';\n    }\n    return 'auto';\n};\n\nregisterQmlType({\n  module:   'QtQuick.Controls',\n  name:     'ScrollView',\n  versions: /.*/,\n  baseClass: 'QtQuick.Item',\n  constructor: QMLScrollView\n});\n","function QMLTextArea(meta) {\n  callSuper(this, meta);\n  const textarea = this.impl;\n  textarea.style.padding = '5px';\n  textarea.style.borderWidth = '1px';\n  textarea.style.backgroundColor = '#fff';\n}\n\nregisterQmlType({\n  module: 'QtQuick.Controls',\n  name: 'TextArea',\n  versions: /.*/,\n  baseClass: 'QtQuick.TextEdit',\n  constructor: QMLTextArea\n});\n","/**\n *\n * TextField is used to accept a line of text input.\n * Input constraints can be placed on a TextField item\n * (for example, through a validator or inputMask).\n * Setting echoMode to an appropriate value enables TextField\n * to be used for a password input field.\n *\n * Valid entries for echoMode and alignment are defined in TextInput.\n *\n */\n\nregisterQmlType({\n    module: 'QtQuick.Controls',\n    name: 'TextField',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLTextInput\n});\n\nfunction QMLTextInput(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    this.font = new getConstructor('QtQuick', '2.0', 'Font')(this);\n\n    const input = this.impl = document.createElement('input');\n    input.type = 'text';\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    input.style.margin = \"0\";\n    input.style.width = \"100%\";\n    this.dom.appendChild(input);\n\n    this.setupFocusOnDom(input);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"int\", this, \"maximumLength\");\n    createProperty(\"bool\", this, \"readOnly\");\n    createProperty(\"var\", this, \"validator\");\n    createProperty(\"enum\", this, \"echoMode\");\n    this.accepted = Signal();\n    this.readOnly = false;\n    this.maximumLength = -1;\n    input.disabled = false;\n\n    this.Component.completed.connect(this, function () {\n        this.implicitWidth = input.offsetWidth;\n        this.implicitHeight = input.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function (newVal) {\n        input.value = newVal;\n    });\n\n    this.echoModeChanged.connect(this, (function (newVal) {\n        switch (newVal) {\n        case TextField.Normal:\n            input.type = \"text\";\n            break;\n        case TextField.Password:\n            input.type = \"password\";\n            break;\n        }\n    }).bind(this));\n\n    this.maximumLengthChanged.connect(this, function (newVal) {\n        if (newVal < 0)\n            newVal = null;\n        input.maxLength = newVal;\n    });\n\n    this.readOnlyChanged.connect(this, function (newVal) {\n        input.disabled = newVal;\n    });\n\n    this.Keys.pressed.connect(this, (function (e) {\n        if ((e.key === Qt.Key_Return || e.key === Qt.Key_Enter) &&\n            testValidator()) {\n            self.accepted();\n            e.accepted = true;\n        }\n    }).bind(this));\n\n    function testValidator() {\n        if (typeof self.validator !== 'undefined' && self.validator !== null)\n            return self.validator.validate(self.text);\n        return true;\n    }\n\n    function updateValue(e) {\n        if (self.text !== self.dom.firstChild.value) {\n            self.$canEditReadOnlyProperties = true;\n            self.text = self.dom.firstChild.value;\n            self.$canEditReadOnlyProperties = false;\n        }\n    }\n\n    input.oninput = updateValue;\n    input.onpropertychanged = updateValue;\n}\n","registerQmlType({\n    module: 'QtQuick.Window',\n    name: 'Screen',\n    versions: /.*/,\n    baseClass: 'QtQuick.Item',\n    constructor: QMLScreen\n});\n\nfunction QMLScreen(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    // TODO: rewrite as an attached object and forbid constructing\n\n    createProperty(\"int\", this, \"desktopAvailableHeight\");\n    createProperty(\"int\", this, \"desktopAvailableWidth\");\n    createProperty(\"real\", this, \"devicePixelRatio\");\n    createProperty(\"int\", this, \"height\");\n    createProperty(\"string\", this, \"name\");\n    createProperty(\"enum\", this, \"orientation\");\n    createProperty(\"enum\", this, \"orientationUpdateMask\");\n    createProperty(\"real\", this, \"pixelDensity\");\n    createProperty(\"enum\", this, \"primaryOrientation\");\n    createProperty(\"int\", this, \"width\");\n\n    this.Component.completed.connect(this, updateSC);\n\n    function updateSC() {\n        self.desktopAvailableHeight = window.outerHeight;\n        self.desktopAvailableWidth = window.outerWidth;\n        self.devicePixelRatio = window.devicePixelRatio;\n        self.height = window.innerHeight;\n        self.name = this.name;\n        self.orientation =  Qt.PrimaryOrientation;\n        self.orientationUpdateMask = 0;\n        self.pixelDensity = 100.0;  // TODO\n        self.primaryOrientation =  Qt.PrimaryOrientation;\n        self.width = window.innerWidth;\n    }\n}\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'AnimatedImage',\n  versions: /.*/,\n  baseClass: 'Image',\n  constructor: function QMLAnimatedImage(meta) {\n    callSuper(this, meta);\n  }\n});\n","function QMLAnimation(meta) {\n    callSuper(this, meta);\n\n    // Exports\n    this.Animation = {\n        Infinite: -1\n    };\n\n    createProperty(\"bool\", this, \"alwaysRunToEnd\");\n    createProperty(\"int\", this, \"loops\", {initialValue: 1});\n    createProperty(\"bool\", this, \"paused\");\n    createProperty(\"bool\", this, \"running\");\n\n    // Methods\n    this.restart = function() {\n        this.stop();\n        this.start();\n    };\n    this.start = function() {\n        this.running = true;\n    }\n    this.stop = function() {\n        this.running = false;\n    }\n    this.pause = function() {\n        this.paused = true;\n    }\n    this.resume = function() {\n        this.paused = false;\n    }\n\n    // To be overridden\n    this.complete = unboundMethod;\n}\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'Animation',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: QMLAnimation\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Behavior',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLBehavior(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"Animation\", this, \"animation\");\n    this.$defaultProperty = \"animation\";\n    createProperty(\"bool\", this, \"enabled\", {initialValue: true});\n\n    this.animationChanged.connect(this, function(newVal) {\n        newVal.target = this.$parent;\n        newVal.property = meta.object.$on;\n        this.$parent.$properties[meta.object.$on].animation = newVal;\n    });\n    this.enabledChanged.connect(this, function(newVal) {\n        this.$parent.$properties[meta.object.$on].animation = newVal ? this.animation : null;\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'BorderImage',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLBorderImage(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    this.BorderImage = {\n        // tileMode\n        Stretch: \"stretch\",\n        Repeat: \"repeat\",\n        Round: \"round\",\n        // status\n        Null: 1,\n        Ready: 2,\n        Loading: 3,\n        Error: 4\n    }\n\n    createProperty(\"url\", this, \"source\");\n    createProperty(\"enum\", this, \"status\", {initialValue: this.BorderImage.Null});\n    this.border = new QObject(this);\n    createProperty(\"int\", this.border, \"left\");\n    createProperty(\"int\", this.border, \"right\");\n    createProperty(\"int\", this.border, \"top\");\n    createProperty(\"int\", this.border, \"bottom\");\n    createProperty(\"enum\", this, \"horizontalTileMode\", {initialValue: this.BorderImage.Stretch});\n    createProperty(\"enum\", this, \"verticalTileMode\", {initialValue: this.BorderImage.Stretch});\n\n    this.sourceChanged.connect(this, function() {\n        this.dom.style.borderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n    });\n    this.border.leftChanged.connect(this, updateBorder);\n    this.border.rightChanged.connect(this, updateBorder);\n    this.border.topChanged.connect(this, updateBorder);\n    this.border.bottomChanged.connect(this, updateBorder);\n    this.horizontalTileModeChanged.connect(this, updateBorder);\n    this.verticalTileModeChanged.connect(this, updateBorder);\n\n    function updateBorder() {\n        this.dom.style.MozBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n        this.dom.style.MozBorderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.MozBorderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.MozBorderImageWidth = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left;\n\n        this.dom.style.webkitBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n        this.dom.style.webkitBorderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.webkitBorderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.webkitBorderImageWidth = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left;\n\n        this.dom.style.OBorderImageSource = \"url(\" + engine.$resolvePath(this.source) + \")\";\n        this.dom.style.OBorderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.OBorderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.OBorderImageWidth = this.border.top + \"px \"\n                                                + this.border.right + \"px \"\n                                                + this.border.bottom + \"px \"\n                                                + this.border.left + \"px\";\n\n        this.dom.style.borderImageSlice = this.border.top + \" \"\n                                                + this.border.right + \" \"\n                                                + this.border.bottom + \" \"\n                                                + this.border.left + \" \"\n                                                + \"fill\";\n        this.dom.style.borderImageRepeat = this.horizontalTileMode + \" \"\n                                                    + this.verticalTileMode;\n        this.dom.style.borderImageWidth = this.border.top + \"px \"\n                                                + this.border.right + \"px \"\n                                                + this.border.bottom + \"px \"\n                                                + this.border.left + \"px\";\n    }\n  }\n});\n","// TODO\n// Currently only a skeleton implementation\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Canvas',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function(meta) {\n        callSuper(this, meta);\n\n        var self = this;\n\n        createProperty('bool', this, 'available');\n        createProperty('var', this, 'canvasSize');\n        createProperty('var', this, 'canvasWindow');\n        createProperty('var', this, 'context');\n        createProperty('string', this, 'contextType');\n        createProperty('enum', this, 'renderStrategy');\n        createProperty('enum', this, 'renderTarget');\n        createProperty('var', this, 'tileSize');\n\n        this.available = true;\n        this.canvasSize = [0, 0];\n        this.canvasWindow = [0, 0, 0, 0];\n        this.context = {};\n        this.contextType = \"contextType\";\n        this.renderStrategy = 0;\n        this.renderTarget = 0;\n        this.tileSize = [0, 0];\n\n        this.imageLoaded = Signal();\n        this.paint = Signal([{type: \"var\", name: \"region\"}]);\n        this.painted = Signal();\n\n        this.cancelRequestAnimationFrame = function(handle) {\n            return false;\n        };\n\n        this.getContext = function(context_id) {\n            var args = arguments.slice(1, arguments.length);\n            return {};\n        };\n\n        this.isImageError = function(image) {\n            return true;\n        };\n\n        this.isImageLoaded = function(image) {\n            return false;\n        };\n\n        this.isImageLoading = function(image) {\n            return false;\n        };\n\n        this.loadImage = function(image) {\n            //loadImageAsync(image);\n            if (this.isImageLoaded(image))\n                this.imageLoaded();\n        };\n\n        this.markDirty = function(area) {\n            // if dirty\n            this.paint(area);\n        };\n\n        this.requestAnimationFrame = function(callback) {\n            return 0;\n        };\n\n        this.requestPaint = function() {\n        };\n\n        this.save = function(file_name) {\n            return false;\n        };\n\n        this.toDataURL = function(mime_type) {\n            return \"\";\n        };\n\n        this.unloadImage = function(image) {\n        };\n    }\n});\n","function QMLColumn(meta) {\n    callSuper(this, meta);\n}\n\nQMLColumn.prototype.layoutChildren = function() {\n    var curPos = 0,\n        maxWidth = 0;\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height))\n            continue;\n        maxWidth = child.width > maxWidth ? child.width : maxWidth;\n\n        child.y = curPos;\n        curPos += child.height + this.spacing;\n    }\n    this.implicitWidth = maxWidth;\n    this.implicitHeight = curPos - this.spacing; // We want no spacing at the bottom side\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name:   'Column',\n  versions: /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLColumn\n});\n","global.DoubleValidator = {\n  StandardNotation: 1, ScientificNotation: 2\n};\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'DoubleValidator',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLDoubleValidator(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"bottom\");\n    createProperty(\"real\", this, \"top\");\n    createProperty(\"int\",  this, \"decimals\");\n    createProperty(\"enum\", this, \"notation\");\n    this.bottom   = -Infinity;\n    this.top      = Infinity;\n    this.decimals = 1000;\n    this.notation = DoubleValidator.ScientificNotation;\n\n    var standardRegExp   = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?$/;\n    var scientificRegExp = /^(-|\\+)?\\s*[0-9]+(\\.[0-9]+)?(E(-|\\+)?[0-9]+)?$/;\n\n    this.getRegExpForNotation = (function(notation) {\n      switch (notation) {\n        case DoubleValidator.ScientificNotation:\n          return scientificRegExp;\n          break ;\n        case DoubleValidator.StandardNotation:\n          return standardRegExp;\n          break ;\n      }\n      return null;\n    }).bind(this);\n\n    function getDecimalsForNumber(number) {\n      if (Math.round(number) != number) {\n        var str = '' + number;\n\n        return /\\d*$/.exec(str)[0].length;\n      }\n      return 0;\n    }\n\n    this.validate = (function(string) {\n      var regExp     = this.getRegExpForNotation(this.notation);\n      var acceptable = regExp.test(string.trim());\n\n      if (acceptable) {\n        var value    = parseFloat(string);\n\n        acceptable   = this.bottom <= value && this.top >= value;\n        acceptable   = acceptable && getDecimalsForNumber(value) <= this.decimals;\n      }\n      return acceptable;\n    }).bind(this);\n  }\n});\n\n","function QMLFlow(meta) {\n    callSuper(this, meta);\n\n    this.Flow = {\n        LeftToRight: 0,\n        TopToBottom: 1\n    }\n\n    createProperty(\"enum\", this, \"flow\", {initialValue: this.Flow.LeftToRight});\n    createProperty(\"enum\", this, \"layoutDirection\", {initialValue: 0});\n\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.widthChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLFlow.prototype.layoutChildren = function() {\n    var curHPos = 0,\n        curVPos = 0,\n        rowSize = 0;\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height))\n            continue;\n\n        if (this.flow == this.Flow.LeftToRight) {\n            if (curHPos + child.width > this.width) {\n                curHPos = 0;\n                curVPos += rowSize + this.spacing;\n                rowSize = 0;\n            }\n            rowSize = child.height > rowSize ? child.height : rowSize;\n\n            child.x = this.layoutDirection == 1\n                    ? this.width - curHPos - child.width : curHPos;\n            child.y = curVPos;\n            curHPos += child.width + this.spacing;\n        } else {\n            if (curVPos + child.height > this.height) {\n                curVPos = 0;\n                curHPos += rowSize + this.spacing;\n                rowSize = 0;\n            }\n            rowSize = child.width > rowSize ? child.width : rowSize;\n\n            child.x = this.layoutDirection == 1\n                    ? this.width - curHPos - child.width : curHPos;\n            child.y = curVPos;\n            curVPos += child.height + this.spacing;\n        }\n    }\n    if (this.flow == 0)\n        this.implicitHeight = curVPos + rowSize;\n    else\n        this.implicitWidth = curHPos + rowSize;\n}\n\nregisterQmlType({\n  module:      'QtQuick',\n  name:        'Flow',\n  versions:    /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLFlow\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Font',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLFont(parent) {\n    QObject.call(this);\n    createProperty(\"bool\", this, \"bold\");\n    createProperty(\"enum\", this, \"capitalization\", {initialValue: 0});\n    createProperty(\"string\", this, \"family\", {initialValue: 'sans-serif'});\n    createProperty(\"bool\", this, \"italic\");\n    createProperty(\"real\", this, \"letterSpacing\");\n    createProperty(\"int\", this, \"pixelSize\", {initialValue: 13});\n    createProperty(\"real\", this, \"pointSize\", {initialValue: 10});\n    createProperty(\"bool\", this, \"strikeout\");\n    createProperty(\"bool\", this, \"underline\");\n    createProperty(\"enum\", this, \"weight\");\n    createProperty(\"real\", this, \"wordSpacing\");\n    var sizeLock = false;\n\n        this.boldChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontWeight =\n                parent.font.weight !== undefined ? parent.font.weight :\n                newVal ? \"bold\" : \"normal\";\n        });\n        this.capitalizationChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontVariant =\n                newVal == \"smallcaps\" ? \"small-caps\" : \"normal\";\n            newVal = newVal == \"smallcaps\" ? \"none\" : newVal;\n            parent.dom.firstChild.style.textTransform = newVal;\n        });\n        this.familyChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontFamily = newVal;\n        });\n        this.italicChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontStyle = newVal ? \"italic\" : \"normal\";\n        });\n        this.letterSpacingChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.letterSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n        });\n        this.pixelSizeChanged.connect(newVal => {\n            if (!sizeLock) {\n              this.pointSize = newVal * 0.75;\n            }\n            const val = newVal + 'px';\n            parent.dom.style.fontSize = val;\n            parent.dom.firstChild.style.fontSize = val;\n        });\n        this.pointSizeChanged.connect(newVal => {\n            sizeLock = true;\n            this.pixelSize = Math.round(newVal / 0.75);\n            sizeLock = false;\n        });\n        this.strikeoutChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.textDecoration = newVal\n                ? \"line-through\"\n                : parent.font.underline\n                ? \"underline\"\n                : \"none\";\n        });\n        this.underlineChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.textDecoration = parent.font.strikeout\n                ? \"line-through\"\n                : newVal\n                ? \"underline\"\n                : \"none\";\n        });\n        this.weightChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.fontWeight =\n                newVal !== undefined ? newVal :\n                parent.font.bold ? \"bold\" : \"normal\";\n        });\n        this.wordSpacingChanged.connect(function(newVal) {\n            parent.dom.firstChild.style.wordSpacing = newVal !== undefined ? newVal + \"px\" : \"\";\n        });\n  }\n});\n\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'FontLoader',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLFontLoader(meta) {\n    callSuper(this, meta);\n\n    // Exports.\n    this.FontLoader = {\n        // status\n        Null: 0,\n        Ready: 1,\n        Loading: 2,\n        Error: 3\n    }\n\n    createProperty(\"string\", this, \"name\");\n    createProperty(\"url\", this, \"source\");\n    createProperty(\"enum\", this, \"status\");\n\n    this.status = this.FontLoader.Null;\n\n    var self = this,\n        domStyle = document.createElement('style'),\n        lastName = '',\n        inTouchName = false;\n\n    // Maximum timeout is the maximum time for a font to load. If font isn't loaded in this time, the status is set to Error.\n    // For both cases (with and without FontLoader.js) if the font takes more than the maximum timeout to load,\n    // dimensions recalculations for elements that are using this font will not be triggered or will have no effect.\n\n    // FontLoader.js uses only the last timeout. The state and name properties are set immediately when the font loads.\n    // If the font could not be loaded, the Error status will be set only when this timeout expires.\n    // If the font loading takes more than the timeout, the name property is set, but the status is set to Error.\n\n    // Fallback sets the font name immediately and touches it several times to trigger dimensions recalcuations.\n    // The status is set to Error and should not be used.\n    var timeouts = [20, 50, 100, 300, 500, 1000, 3000, 5000, 10000, 15000]; // 15 seconds maximum\n\n    function cycleTouchName(fontName, i) {\n        if (lastName !== fontName)\n            return;\n        if (i > 0) {\n            var name = self.name;\n            inTouchName = true;\n            // Calling self.nameChanged() is not enough, we have to actually change the value to flush the bindings.\n            self.name = 'sans-serif';\n            self.name = name;\n            inTouchName = false;\n        }\n        if (i < timeouts.length) {\n            setTimeout(function() {\n                cycleTouchName(fontName, i + 1);\n            }, timeouts[i] - (i > 0 ? timeouts[i - 1] : 0));\n        }\n    }\n\n    function loadFont(fontName) {\n        if ((lastName === fontName) || inTouchName)\n           return;\n        lastName = fontName;\n\n        if (!fontName) {\n            self.status = self.FontLoader.Null;\n            return;\n        }\n        self.status = self.FontLoader.Loading;\n        if (typeof FontLoader !== 'undefined') {\n            var fontLoader = new FontLoader([fontName], {\n                \"fontsLoaded\": function(error) {\n                    if (error !== null) {\n                        if ((lastName === fontName) && (error.notLoadedFontFamilies[0] === fontName)) {\n                            self.name = fontName; // Set the name for the case of font loading after the timeout.\n                            self.status = self.FontLoader.Error;\n                        }\n                    }\n                },\n                \"fontLoaded\": function(fontFamily) {\n                    if ((lastName === fontName) && (fontFamily == fontName)) {\n                        self.name = fontName;\n                        self.status = self.FontLoader.Ready;\n                    }\n                }\n            }, timeouts[timeouts.length - 1]);\n            FontLoader.testDiv = null; // Else I get problems loading multiple fonts (FontLoader.js bug?)\n            fontLoader.loadFonts();\n        } else {\n            console.warn('FontLoader.js library is not loaded.\\nYou should load https://github.com/smnh/FontLoader if you want to use QtQuick FontLoader elements.')\n            self.status = self.FontLoader.Error; // You should not rely on 'status' property without FontLoader.js.\n            self.name = fontName;\n            cycleTouchName(fontName, 0)\n        }\n    }\n\n    this.sourceChanged.connect(this, function(font_src) {\n        var fontName = 'font_' + ((new Date()).getTime()).toString(36) + '_' + (Math.round(Math.random() * 1e15)).toString(36);\n        domStyle.innerHTML = '@font-face { font-family: \\'' + fontName + '\\'; src: url(\\'' + engine.$resolvePath(font_src) + '\\'); }';\n        document.getElementsByTagName('head')[0].appendChild(domStyle);\n        loadFont(fontName);\n    });\n\n    this.nameChanged.connect(this, loadFont);\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name: 'Grid',\n  versions: /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLGrid\n});\n\nfunction QMLGrid(meta) {\n    callSuper(this, meta);\n\n    this.Grid = {\n        LeftToRight: 0,\n        TopToBottom: 1\n    }\n\n    createProperty(\"int\", this, \"columns\");\n    createProperty(\"int\", this, \"rows\");\n    createProperty(\"enum\", this, \"flow\", {initialValue: 0});\n    createProperty(\"enum\", this, \"layoutDirection\", {initialValue: 0});\n    this.columnsChanged.connect(this, this.layoutChildren);\n    this.rowsChanged.connect(this, this.layoutChildren);\n    this.flowChanged.connect(this, this.layoutChildren);\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLGrid.prototype.layoutChildren = function() {\n    var visibleItems = [],\n        r = 0, c = 0,\n        colWidth = [],\n        rowHeight = [],\n        gridWidth = -this.spacing,\n        gridHeight = -this.spacing,\n        curHPos = 0,\n        curVPos = 0;\n\n    // How many items are actually visible?\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (child.visible && child.width && child.height)\n            visibleItems.push(this.children[i]);\n    }\n\n    // How many rows and columns do we need?\n    if (!this.columns && !this.rows) {\n        c = 4;\n        r = Math.ceil(visibleItems.length / 4);\n    } else if (!this.columns) {\n        r = this.rows;\n        c = Math.ceil(visibleItems.length / r);\n    } else {\n        c = this.columns;\n        r = Math.ceil(visibleItems.length / c);\n    }\n\n    // How big are the colums/rows?\n    if (this.flow == 0)\n        for (var i = 0; i < r; i++) {\n            for (var j = 0; j < c; j++) {\n                var item = visibleItems[i*c+j];\n                if (!item)\n                    break;\n                if (!colWidth[j] || item.width > colWidth[j])\n                    colWidth[j] = item.width;\n                if (!rowHeight[i] || item.height > rowHeight[i])\n                    rowHeight[i] = item.height;\n            }\n        }\n    else\n        for (var i = 0; i < c; i++) {\n            for (var j = 0; j < r; j++) {\n                var item = visibleItems[i*r+j];\n                if (!item)\n                    break;\n                if (!rowHeight[j] || item.height > rowHeight[j])\n                    rowHeight[j] = item.height;\n                if (!colWidth[i] || item.width > colWidth[i])\n                    colWidth[i] = item.width;\n            }\n        }\n\n    for (var i in colWidth)\n        gridWidth += colWidth[i] + this.spacing;\n    for (var i in rowHeight)\n        gridHeight += rowHeight[i] + this.spacing;\n\n    // Do actual positioning\n    // When layoutDirection is RightToLeft we need oposite order of coumns\n    var step = this.layoutDirection == 1 ? -1 : 1,\n        startingPoint = this.layoutDirection == 1 ? c - 1 : 0,\n        endPoint = this.layoutDirection == 1 ? -1 : c;\n    if (this.flow == 0)\n        for (var i = 0; i < r; i++) {\n            for (var j = startingPoint; j !== endPoint; j += step) {\n                var item = visibleItems[i*c+j];\n                if (!item)\n                    break;\n                item.x = curHPos;\n                item.y = curVPos;\n\n                curHPos += colWidth[j] + this.spacing;\n            }\n            curVPos += rowHeight[i] + this.spacing;\n            curHPos = 0;\n        }\n    else\n        for (var i = startingPoint; i !== endPoint; i += step) {\n            for (var j = 0; j < r; j++) {\n                var item = visibleItems[i*r+j];\n                if (!item)\n                    break;\n                item.x = curHPos;\n                item.y = curVPos;\n\n                curVPos += rowHeight[j] + this.spacing;\n            }\n            curHPos += colWidth[i] + this.spacing;\n            curVPos = 0;\n        }\n\n    this.implicitWidth = gridWidth;\n    this.implicitHeight = gridHeight;\n}\n","function QMLImage(meta) {\n    callSuper(this, meta);\n    var img = new Image(),\n        self = this;\n\n    // Exports.\n    this.Image = {\n        // fillMode\n        Stretch: 1,\n        PreserveAspectFit: 2,\n        PreserveAspectCrop: 3,\n        Tile: 4,\n        TileVertically: 5,\n        TileHorizontally: 6,\n        // status\n        Null: 1,\n        Ready: 2,\n        Loading: 3,\n        Error: 4\n    }\n\n    // no-op properties\n    createProperty(\"bool\", this, \"asynchronous\", {initialValue: true});\n    createProperty(\"bool\", this, \"cache\", {initialValue: true});\n    createProperty(\"bool\", this, \"smooth\", {initialValue: true});\n\n    createProperty(\"enum\", this, \"fillMode\", {initialValue: this.Image.Stretch});\n    createProperty(\"bool\", this, \"mirror\");\n    createProperty(\"real\", this, \"progress\");\n    createProperty(\"url\", this, \"source\");\n    createProperty(\"enum\", this, \"status\", {initialValue: this.Image.Null});\n\n    this.sourceSize = new QObject(this);\n\n    createProperty(\"int\", this.sourceSize, \"width\");\n    createProperty(\"int\", this.sourceSize, \"height\");\n\n    const bg = this.impl = document.createElement('div');\n    bg.style.pointerEvents = 'none';\n    bg.style.height = '100%';\n    this.dom.appendChild(bg);\n\n    // Bind status to img element\n    img.onload = function() {\n        var w = img.naturalWidth;\n        var h = img.naturalHeight;\n        self.sourceSize.width = w;\n        self.sourceSize.height = h;\n        self.implicitWidth = w;\n        self.implicitHeight = h;\n\n        self.progress = 1;\n        self.status = self.Image.Ready;\n    }\n    img.onerror = function() {\n        self.status = self.Image.Error;\n    }\n\n    var updateFillMode = function(val) {\n      if (typeof val == 'undefined')\n        val = this.fillMode;\n      switch (val) {\n        default:\n        case this.Image.Stretch:\n          bg.style.backgroundRepeat   = 'auto';\n          bg.style.backgroundSize     = '100% 100%';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n        case this.Image.Tile:\n          bg.style.backgroundRepeat   = 'auto';\n          bg.style.backgroundSize     = 'auto';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n        case this.Image.PreserveAspectFit:\n          bg.style.backgroundRepeat   = 'no-repeat';\n          bg.style.backgroundSize     = 'contain';\n          bg.style.backgroundPosition = 'center';\n          break ;\n        case this.Image.PreserveAspectCrop:\n          bg.style.backgroundRepeat   = 'no-repeat';\n          bg.style.backgroundSize     = 'cover';\n          bg.style.backgroundPosition = 'center';\n          break ;\n        case this.Image.TileVertically:\n          bg.style.backgroundRepeat   = 'repeat-y';\n          bg.style.backgroundSize     = '100% auto';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n        case this.Image.TileHorizontally:\n          bg.style.backgroundRepeat   = 'repeat-x';\n          bg.style.backgroundSize     = 'auto 100%';\n          bg.style.backgroundPosition = 'auto';\n          break ;\n      }\n    }\n    updateFillMode = updateFillMode.bind(this);\n\n    var updateMirroring = (function(val) {\n      var transformRule = 'scale(-1,1)';\n      if (!val)\n      {\n        var index = this.transform.indexOf(transformRule);\n\n        if (index >= 0)\n          this.transform.splice(index, 1);\n      }\n      else\n        this.transform.push(transformRule);\n      this.$updateTransform();\n    }).bind(this);\n\n    this.sourceChanged.connect(this, function(val) {\n        this.progress = 0;\n        this.status = this.Image.Loading;\n        bg.style.backgroundImage=\"url('\" + engine.$resolvePath(val) + \"')\";\n        img.src = engine.$resolvePath(val);\n        if (img.complete)\n          this.status = this.Image.Ready;\n        updateFillMode();\n    });\n\n    this.mirrorChanged.connect  (this, updateMirroring);\n    this.fillModeChanged.connect(this, updateFillMode);\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name:   'Image',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLImage\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'IntValidator',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLIntValidator(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"int\", this, \"bottom\");\n    createProperty(\"int\", this, \"top\");\n    this.bottom = -2147483647;\n    this.top    = 2147483647;\n\n    this.validate = (function(string) {\n      var regExp     = /^(-|\\+)?\\s*[0-9]+$/;\n      var acceptable = regExp.test(string.trim());\n\n      if (acceptable) {\n        var value    = parseInt(string);\n\n        acceptable   = this.bottom <= value && this.top >= value;\n      }\n      return acceptable;\n    }).bind(this);\n  }\n});\n\n","function QMLItem(meta) {\n    callSuper(this, meta);\n    var child,\n        o, i;\n\n    if (this.$parent === null) { // This is the root element. Initialize it.\n        this.dom = engine.rootElement || document.body;\n        this.dom.innerHTML = \"\";\n        var self = this;\n        this.dom.style.position = \"relative\"; // Needed to make absolute positioning work\n        this.dom.style.top = \"0\";\n        this.dom.style.left = \"0\";\n        this.dom.style.overflow = \"hidden\"; // No QML stuff should stand out the root element\n    } else {\n        if (!this.dom) // Create a dom element for this item.\n            this.dom = document.createElement(\"div\");\n        this.dom.style.position = \"absolute\";\n    }\n    this.dom.style.pointerEvents = \"none\";\n    this.dom.className = meta.object.$class + (this.id ? \" \" + this.id : \"\");\n    this.css = this.dom.style;\n    this.impl = null; // Store the actually drawn element\n\n    this.css.boxSizing = 'border-box';\n\n    createProperty(\"list\", this, \"data\");\n    this.$defaultProperty = \"data\";\n    createProperty(\"list\", this, \"children\");\n    createProperty(\"list\", this, \"resources\");\n    createProperty(\"Item\", this, \"parent\");\n    this.children = [];\n    this.resources = [];\n    this.parentChanged.connect(this, function(newParent, oldParent) {\n        if (oldParent) {\n            oldParent.children.splice(oldParent.children.indexOf(this), 1);\n            oldParent.childrenChanged();\n            oldParent.dom.removeChild(this.dom);\n        }\n        if (newParent && newParent.children.indexOf(this) == -1) {\n            newParent.children.push(this);\n            newParent.childrenChanged();\n        }\n        if (newParent)\n            newParent.dom.appendChild(this.dom);\n    });\n    this.parentChanged.connect(this, updateHGeometry);\n    this.parentChanged.connect(this, updateVGeometry);\n    this.dataChanged.connect(this, function(newData) {\n        for (var i in newData) {\n            var child = newData[i];\n            if (child.hasOwnProperty(\"parent\")) // Seems to be an Item. TODO: Use real inheritance and ask using instanceof.\n                child.parent = this; // This will also add it to children.\n            else\n                this.resources.push(child);\n        }\n    });\n\n    if (this.$isComponentRoot)\n      createProperty(\"var\", this, \"activeFocus\");\n    createProperty(\"real\", this, \"x\");\n    createProperty(\"real\", this, \"y\");\n    createProperty(\"real\", this, \"width\");\n    createProperty(\"real\", this, \"height\");\n    createProperty(\"real\", this, \"implicitWidth\");\n    createProperty(\"real\", this, \"implicitHeight\");\n    createProperty(\"real\", this, \"left\");\n    createProperty(\"real\", this, \"right\");\n    createProperty(\"real\", this, \"top\");\n    createProperty(\"real\", this, \"bottom\");\n    createProperty(\"real\", this, \"horizontalCenter\");\n    createProperty(\"real\", this, \"verticalCenter\");\n    createProperty(\"real\", this, \"rotation\");\n    createProperty(\"real\", this, \"scale\", {initialValue: 1});\n    createProperty(\"real\", this, \"z\");\n    createProperty(\"list\", this, \"transform\");\n    createProperty(\"bool\", this, \"visible\", {initialValue: true});\n    createProperty(\"real\", this, \"opacity\", {initialValue: 1});\n    createProperty(\"bool\", this, \"clip\");\n    createProperty(\"bool\", this, \"focus\");\n\n    createProperty(\"real\", this, \"$opacity\", {initialValue: 1});\n\n    this.xChanged.connect(this, updateHGeometry);\n    this.yChanged.connect(this, updateVGeometry);\n    this.widthChanged.connect(this, updateHGeometry);\n    this.heightChanged.connect(this, updateVGeometry);\n    this.implicitWidthChanged.connect(this, updateHGeometry);\n    this.implicitHeightChanged.connect(this, updateVGeometry);\n\n    this.setupFocusOnDom = (function(element) {\n      var updateFocus = (function() {\n        var hasFocus = document.activeElement == this.dom || document.activeElement == this.dom.firstChild;\n\n        if (this.focus != hasFocus)\n          this.focus = hasFocus;\n      }).bind(this);\n      element.addEventListener(\"focus\", updateFocus);\n      element.addEventListener(\"blur\",  updateFocus);\n    }).bind(this);\n\n    this.focusChanged.connect(this, (function(newVal) {\n      if (newVal == true) {\n        if (this.dom.firstChild != null)\n          this.dom.firstChild.focus();\n        document.qmlFocus = this;\n        this.$context.activeFocus = this;\n      } else if (document.qmlFocus == this) {\n        document.getElementsByTagName(\"BODY\")[0].focus();\n        document.qmlFocus = engine.rootContext().base;\n        this.$context.activeFocus = null;\n      }\n    }).bind(this));\n\n    this.$isUsingImplicitWidth = true;\n    this.$isUsingImplicitHeight = true;\n\n    this.anchors = new QObject(this);\n    createProperty(\"var\", this.anchors, \"left\");\n    createProperty(\"var\", this.anchors, \"right\");\n    createProperty(\"var\", this.anchors, \"top\");\n    createProperty(\"var\", this.anchors, \"bottom\");\n    createProperty(\"var\", this.anchors, \"horizontalCenter\");\n    createProperty(\"var\", this.anchors, \"verticalCenter\");\n    createProperty(\"Item\", this.anchors, \"fill\");\n    createProperty(\"Item\", this.anchors, \"centerIn\");\n    createProperty(\"real\", this.anchors, \"margins\");\n    createProperty(\"real\", this.anchors, \"leftMargin\");\n    createProperty(\"real\", this.anchors, \"rightMargin\");\n    createProperty(\"real\", this.anchors, \"topMargin\");\n    createProperty(\"real\", this.anchors, \"bottomMargin\");\n    this.anchors.leftChanged.connect(this, updateHGeometry);\n    this.anchors.rightChanged.connect(this, updateHGeometry);\n    this.anchors.topChanged.connect(this, updateVGeometry);\n    this.anchors.bottomChanged.connect(this, updateVGeometry);\n    this.anchors.horizontalCenterChanged.connect(this, updateHGeometry);\n    this.anchors.verticalCenterChanged.connect(this, updateVGeometry);\n    this.anchors.fillChanged.connect(this, updateHGeometry);\n    this.anchors.fillChanged.connect(this, updateVGeometry);\n    this.anchors.centerInChanged.connect(this, updateHGeometry);\n    this.anchors.centerInChanged.connect(this, updateVGeometry);\n    this.anchors.leftMarginChanged.connect(this, updateHGeometry);\n    this.anchors.rightMarginChanged.connect(this, updateHGeometry);\n    this.anchors.topMarginChanged.connect(this, updateVGeometry);\n    this.anchors.bottomMarginChanged.connect(this, updateVGeometry);\n    this.anchors.marginsChanged.connect(this, updateHGeometry);\n    this.anchors.marginsChanged.connect(this, updateVGeometry);\n\n    // childrenRect property\n    this.childrenRect = new QObject(this);\n    createProperty(\"real\", this.childrenRect, \"x\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"y\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"width\"); // TODO ro\n    createProperty(\"real\", this.childrenRect, \"height\"); // TODO ro\n\n    createProperty(\"list\", this, \"states\");\n    createProperty(\"string\", this, \"state\");\n    createProperty(\"list\", this, \"transitions\");\n    this.stateChanged.connect(this, function(newVal, oldVal) {\n        var oldState, newState, i, j, k;\n        for (i = 0; i < this.states.length; i++)\n            if (this.states[i].name === newVal)\n                newState = this.states[i];\n            else if (this.states[i].name === oldVal)\n                oldState = this.states[i];\n\n        var actions = this.$revertActions.slice();\n\n        // Get current values for revert actions\n        for (i in actions) {\n            var action  = actions[i];\n            action.from = action.target[action.property];\n        }\n        if (newState) {\n            var changes = newState.$getAllChanges();\n\n            // Get all actions we need to do and create actions to revert them\n            for (i = 0; i < changes.length; i++) {\n                var change = changes[i];\n\n                for (j = 0; j < change.$actions.length; j++) {\n                    var item = change.$actions[j];\n\n                    var action = {\n                        target: change.target,\n                        property: item.property,\n                        origValue: change.target.$properties[item.property].binding\n                                    || change.target.$properties[item.property].val,\n                        value: item.value,\n                        from: change.target[item.property],\n                        to: undefined,\n                        explicit: change.explicit\n                    };\n                    var found = false;\n                    for (k in actions)\n                        if (actions[k].target == action.target\n                            && actions[k].property == action.property) {\n                            found = true;\n                            actions[k] = action;\n                            break;\n                        }\n                    if (!found)\n                        actions.push(action);\n\n                    // Look for existing revert action, else create it\n                    var found = false;\n                    for (k = 0; k < this.$revertActions.length; k++)\n                        if (this.$revertActions[k].target == change.target\n                            && this.$revertActions[k].property == item.property) {\n                            if (!change.restoreEntryValues)\n                                this.$revertActions.splice(k, 1); // We don't want to revert, so remove it\n                            found = true;\n                            break;\n                        }\n                    if (!found && change.restoreEntryValues)\n                        this.$revertActions.push({\n                            target: change.target,\n                            property: item.property,\n                            value: change.target.$properties[item.property].binding\n                                        || change.target.$properties[item.property].val,\n                            from: undefined,\n                            to: change.target[item.property]\n                        });\n                }\n            }\n        }\n\n        // Set all property changes and fetch the actual values afterwards\n        // The latter is needed for transitions. We need to set all properties\n        // before we fetch the values because properties can be interdependent.\n        for (i in actions) {\n            var action = actions[i];\n            action.target.$properties[action.property].set(action.value, QMLProperty.ReasonUser, action.target,\n                                                           newState ? newState.$context: action.target.$context);\n        }\n        for (i in actions) {\n            var action = actions[i];\n            action.to = action.target[action.property];\n            if (action.explicit) {\n                action.target[action.property] = action.target[action.property]; //Remove binding\n                action.value = action.target[action.property];\n            }\n        }\n\n        // Find the best transition to use\n        var transition,\n            rating = 0;\n        for (var i = 0; i < this.transitions.length; i++) {\n            this.transitions[i].$stop(); // We need to stop running transitions, so let's do\n                                        // it while iterating through the transitions anyway\n            var curTransition = this.transitions[i],\n                curRating = 0;\n            if (curTransition.from == oldVal || curTransition.reversible && curTransition.from == newVal)\n                curRating += 2;\n            else if (curTransition.from == \"*\")\n                curRating++;\n            else\n                continue;\n            if (curTransition.to == newVal || curTransition.reversible && curTransition.to == oldVal)\n                curRating += 2;\n            else if (curTransition.to == \"*\")\n                curRating++;\n            else\n                continue;\n            if (curRating > rating) {\n                rating = curRating;\n                transition = curTransition;\n            }\n        }\n        if (transition)\n            transition.$start(actions);\n    });\n\n    var QMLRotation  = getConstructor('QtQuick', '2.0', 'Rotation');\n    var QMLScale     = getConstructor('QtQuick', '2.0', 'Scale');\n    var QMLTranslate = getConstructor('QtQuick', '2.0', 'Translate');\n\n    this.$updateTransform = function() {\n            var transform = \"rotate(\" + this.rotation + \"deg) scale(\" + this.scale + \")\";\n            var filter = \"\";\n            var transformStyle = \"preserve-3d\";\n\n            for (var i = 0; i < this.transform.length; i++) {\n                var t = this.transform[i];\n                if (t instanceof QMLRotation)\n                    transform += \" rotate3d(\" + t.axis.x + \", \" + t.axis.y + \", \" + t.axis.z + \", \" + t.angle + \"deg)\";\n                else if (t instanceof QMLScale)\n                    transform += \" scale(\" + t.xScale + \", \" + t.yScale + \")\";\n                else if (t instanceof QMLTranslate)\n                    transform += \" translate(\" + t.x + \"px, \" + t.y + \"px)\";\n                else if (typeof t.transformType != 'undefined') {\n                    if (t.transformType == 'filter')\n                      filter += t.operation + '(' + t.parameters + ') ';\n                }\n                else if (typeof t == 'string')\n                    transform += t;\n            }\n            if (typeof this.z == \"number\")\n              transform += \" translate3d(0, 0, \" + this.z + \"px)\";\n            this.dom.style.transform = transform;\n            this.dom.style.transformStyle = transformStyle;\n            this.dom.style.MozTransform = transform;    // Firefox\n            this.dom.style.webkitTransform = transform; // Chrome, Safari and Opera\n            this.dom.style.webkitTransformStyle = transformStyle;\n            this.dom.style.OTransform = transform;      // Opera\n            this.dom.style.msTransform = transform;     // IE\n            this.dom.style.filter = filter;\n            this.dom.style.msFilter = filter;     // IE\n            this.dom.style.webkitFilter = filter; // Chrome, Safari and Opera\n            this.dom.style.MozFilter = filter;    // Firefox\n    }\n    this.rotationChanged.connect(this, this.$updateTransform);\n    this.scaleChanged.connect(this, this.$updateTransform);\n    this.transformChanged.connect(this, this.$updateTransform);\n    this.visibleChanged.connect(this, function(newVal) {\n        this.css.visibility = newVal ? \"inherit\" : \"hidden\";\n    });\n    this.clipChanged.connect(this, function(newVal) {\n        this.css.overflow = newVal ? \"hidden\" : \"visible\";\n    });\n    this.zChanged.connect(this, function(newVal) {\n        this.$updateTransform();\n    });\n    this.xChanged.connect(this, function(newVal) {\n        this.css.left = newVal + \"px\";\n    });\n    this.yChanged.connect(this, function(newVal) {\n        this.css.top = newVal + \"px\";\n    });\n    this.widthChanged.connect(this, function(newVal) {\n        this.css.width = newVal ? newVal + \"px\" : \"auto\";\n    });\n    this.heightChanged.connect(this, function(newVal) {\n        this.css.height = newVal ? newVal + \"px\" : \"auto\";\n    });\n\n    this.Component.completed.connect(this, this.$calculateOpacity);\n    this.opacityChanged.connect(this, this.$calculateOpacity);\n    if (this.$parent) {\n      this.$parent.$opacityChanged.connect(this, this.$calculateOpacity);\n    }\n\n    this.spacing = 0;\n    this.$revertActions = [];\n    this.css.left = this.x + 'px';\n    this.css.top = this.y + 'px';\n\n    // Init size of root element\n    if (this.$parent === null) {\n        if (engine.rootElement == undefined) {\n            // Case 1: Qml scene is placed in body tag\n\n            // event handling by addEventListener is probably better than setting window.onresize\n            var updateQmlGeometry = function() {\n                self.implicitHeight = window.innerHeight;\n                self.implicitWidth = window.innerWidth;\n            }\n            window.addEventListener( \"resize\", updateQmlGeometry );\n            updateQmlGeometry();\n        } else {\n            // Case 2: Qml scene is placed in some element tag\n\n            // we have to call `self.implicitHeight =` and `self.implicitWidth =`\n            // each time the rootElement changes it's geometry\n            // to reposition child elements of qml scene\n\n            // it is good to have this as named method of dom element, so we can call it\n            // from outside too, whenever element changes it's geometry (not only on window resize)\n            this.dom.updateQmlGeometry = function() {\n              self.implicitHeight = self.dom.offsetHeight;\n              self.implicitWidth = self.dom.offsetWidth;\n            };\n            window.addEventListener( \"resize\", this.dom.updateQmlGeometry );\n            this.dom.updateQmlGeometry();\n        }\n    }\n}\n\nQMLItem.prototype.$calculateOpacity = function() {\n  // TODO: reset all opacity on layer.enabled changed\n  if (false) { // TODO: check layer.enabled\n    this.css.opacity = this.opacity;\n  }\n  const parentOpacity = (this.$parent && this.$parent.$opacity) || 1;\n  this.$opacity = this.opacity * parentOpacity;\n  if (this.impl) {\n    this.impl.style.opacity = this.$opacity;\n  }\n};\n\nregisterQmlType({\n  module: 'QtQuick',\n  name: 'Item',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: QMLItem\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'ListElement',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLListElement(meta) {\n    callSuper(this, meta);\n\n    for (var i in meta.object) {\n        if (i[0] != \"$\") {\n            createProperty(\"variant\", this, i);\n        }\n    }\n    applyProperties(meta.object, this, this, this.$context);\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'ListModel',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLListModel(meta) {\n    callSuper(this, meta);\n    var self = this,\n    firstItem = true;\n    var QMLListElement = getConstructor('QtQuick', '2.0', 'ListElement');\n\n    createProperty(\"int\", this, \"count\");\n    createProperty(\"list\", this, \"$items\");\n    this.$defaultProperty = \"$items\";\n    this.$model = new JSItemModel();\n\n    this.$itemsChanged.connect(this, function(newVal) {\n        if (firstItem) {\n            firstItem = false;\n            var roleNames = [];\n            var dict = newVal[0];\n            for (var i in (dict instanceof QMLListElement) ? dict.$properties : dict) {\n                if (i != \"index\")\n                    roleNames.push(i);\n            }\n            this.$model.setRoleNames(roleNames);\n        }\n        this.count = this.$items.length;\n    });\n\n    this.$model.data = function(index, role) {\n        return self.$items[index][role];\n    }\n    this.$model.rowCount = function() {\n        return self.$items.length;\n    }\n\n    this.append = function(dict) {\n        this.insert(this.$items.length, dict);\n    }\n    this.clear = function() {\n        this.$items = [];\n        this.$model.modelReset();\n        this.count = 0;\n    }\n    this.get = function(index) {\n        return this.$items[index];\n    }\n    this.insert = function(index, dict) {\n        this.$items.splice(index, 0, dict);\n        this.$itemsChanged(this.$items);\n        this.$model.rowsInserted(index, index+1);\n    }\n    this.move = function(from, to, n) {\n        var vals = this.$items.splice(from, n);\n        for (var i = 0; i < vals.length; i++) {\n            this.$items.splice(to + i, 0, vals[i]);\n        }\n        this.$model.rowsMoved(from, from+n, to);\n    }\n    this.remove = function(index) {\n        this.$items.splice(index, 1);\n        this.$model.rowsRemoved(index, index+1);\n        this.count = this.$items.length;\n    }\n    this.set = function(index, dict) {\n        this.$items[index] = dict;\n        this.$model.dataChanged(index, index);\n    }\n    this.setProperty = function(index, property, value) {\n        this.$items[index][property] = value;\n    }\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'ListView',\n  versions: /.*/,\n  baseClass: 'Repeater',\n  constructor: function QMLListView(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    createProperty(\"enum\", this, \"orientation\");\n    createProperty(\"real\", this, \"spacing\");\n\n    this.container = function() { return self; }\n    this.modelChanged.connect(styleChanged);\n    this.delegateChanged.connect(styleChanged);\n    this.orientationChanged.connect(styleChanged);\n    this.spacingChanged.connect(styleChanged);\n\n    this._childrenInserted.connect(applyStyleOnItem)\n\n    function applyStyleOnItem($item) {\n      $item.dom.style.position = 'initial';\n      if (self.orientation == Qt.Horizontal) {\n        $item.dom.style.display = 'inline-block';\n        if ($item != self.$items[0])\n          $item.dom.style[\"margin-left\"] = self.spacing + \"px\";\n      }\n      else {\n        $item.dom.style.display = 'block';\n        if ($item != self.$items[0])\n          $item.dom.style[\"margin-top\"] = self.spacing + \"px\";\n      }\n    }\n\n    function styleChanged() {\n      for (var i = 0 ; i < self.$items.length ; ++i) {\n        applyStyleOnItem(self.$items[i]);\n      }\n    }\n  }\n});\n","/**\n *\n * Loader is used to dynamically load QML components.\n *\n * Loader can load a QML file (using the source property)\n * or a Component object (using the sourceComponent property).\n * It is useful for delaying the creation of a component until\n * it is required: for example, when a component should be created\n * on demand, or when a component should not be created unnecessarily\n * for performance reasons.\n *\n */\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'Loader',\n    versions: /.*/,\n    baseClass: 'Item',\n    constructor: function(meta) {\n        callSuper(this, meta);\n\n        var self = this;\n\n        createProperty('bool', this, 'active');\n        createProperty('bool', this, 'asynchronous');\n        createProperty('var', this, 'item');\n        createProperty('real', this, 'progress');\n        createProperty('url', this, 'source');\n        createProperty('Component', this, 'sourceComponent');\n        createProperty('enum', this, 'status');\n\n        this.active = true;\n        this.asynchronous = false;\n        this.item = undefined;\n        this.progress = 0.0;\n        this.source = undefined;\n        this.sourceComponent = undefined;\n        this.status = 1;\n\n        this.loaded = Signal();\n\n        this.qml = 'not set';\n        this.sourceUrl = 'empty';\n        this.sourceQml = 'empty';\n\n        this.setSource = function(url, options) {\n            this.sourceUrl = url;\n            this.sourceQml = getUrlContents(url);\n\n            this.props = options;\n            this.source = url;\n            this.sourceComponent = null; // TODO Component\n            this.item = {}; // TODO\n            this.loaded();\n        }\n\n    }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'MouseArea',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLMouseArea(meta) {\n    callSuper(this, meta);\n    var self = this;\n\n    this.dom.style.pointerEvents = \"all\";\n\n    // IE does not handle mouse clicks to transparent divs, so we have\n    // to set a background color and make it invisible using opacity\n    // as that doesn't affect the mouse handling.\n    this.dom.style.backgroundColor = \"white\";\n    this.dom.style.opacity = 0;\n\n    createProperty(\"variant\", this, \"acceptedButtons\", {initialValue: Qt.LeftButton});\n    createProperty(\"bool\", this, \"enabled\", {initialValue: true});\n    createProperty(\"bool\", this, \"hoverEnabled\");\n    createProperty(\"real\", this, \"mouseX\");\n    createProperty(\"real\", this, \"mouseY\");\n    createProperty(\"bool\", this, \"pressed\");\n    createProperty(\"bool\", this, \"containsMouse\");\n    createProperty(\"variant\", this, \"pressedButtons\", {initialValue: 0});\n    createProperty(\"enum\", this, \"cursorShape\", {initialValue: Qt.ArrowCursor});\n\n    this.clicked = Signal([{type: \"variant\", name: \"mouse\"}]);\n    this.entered = Signal();\n    this.exited = Signal();\n    this.positionChanged = Signal([{type: \"variant\", name: \"mouse\"}]);\n\n    function eventToMouse(e) {\n        return {\n            accepted: true,\n            button: e.button == 0 ? Qt.LeftButton :\n                    e.button == 1 ? Qt.MiddleButton :\n                    e.button == 2 ? Qt.RightButton :\n                    0,\n            modifiers: (e.ctrlKey * Qt.CtrlModifier)\n                    | (e.altKey * Qt.AltModifier)\n                    | (e.shiftKey * Qt.ShiftModifier)\n                    | (e.metaKey * Qt.MetaModifier),\n            x: (e.offsetX || e.layerX),\n            y: (e.offsetY || e.layerY)\n        };\n    }\n    function handleClick(e) {\n        var mouse = eventToMouse(e);\n\n        if (self.enabled && self.acceptedButtons & mouse.button) {\n            self.clicked(mouse);\n        }\n        // This decides whether to show the browser's context menu on right click or not\n        return !(self.acceptedButtons & Qt.RightButton);\n    }\n    this.dom.onclick = handleClick;\n    this.dom.oncontextmenu = handleClick;\n    this.dom.onmousedown = function(e) {\n        if (self.enabled) {\n            var mouse = eventToMouse(e);\n            self.mouseX = mouse.x;\n            self.mouseY = mouse.y;\n            self.pressed = true;\n        }\n        self.pressedButtons = mouse.button;\n    }\n    this.dom.onmouseup = function(e) {\n        self.pressed = false;\n        self.pressedButtons = 0;\n    }\n    this.dom.onmouseover = function(e) {\n        self.containsMouse = true;\n        self.entered();\n    }\n    this.dom.onmouseout = function(e) {\n        self.containsMouse = false;\n        self.exited();\n    }\n    this.dom.onmousemove = function(e) {\n        if (self.enabled && (self.hoverEnabled || self.pressed)) {\n            var mouse = eventToMouse(e);\n            self.positionChanged(mouse);\n            self.mouseX = mouse.x;\n            self.mouseY = mouse.y;\n        }\n    }\n\n    function cursorShapeToCSS(){\n        switch (self.cursorShape) {\n          case Qt.ArrowCursor: return 'default';\n          case Qt.UpArrowCursor: return 'n-resize';\n          case Qt.CrossCursor: return 'crosshair';\n          case Qt.WaitCursor: return 'wait';\n          case Qt.IBeamCursor: return 'text';\n          case Qt.SizeVerCursor: return 'ew-resize';\n          case Qt.SizeHorCursor: return 'ns-resize';\n          case Qt.SizeBDiagCursor: return 'nesw-resize';\n          case Qt.SizeFDiagCursor: return 'nwse-resize';\n          case Qt.SizeAllCursor: return 'all-scroll';\n          case Qt.BlankCursor: return 'none';\n          case Qt.SplitVCursor: return 'row-resize';\n          case Qt.SplitHCursor: return 'col-resize';\n          case Qt.PointingHandCursor: return 'pointer';\n          case Qt.ForbiddenCursor: return 'not-allowed';\n          case Qt.WhatsThisCursor: return 'help';\n          case Qt.BusyCursor: return 'progress';\n          case Qt.OpenHandCursor: return 'grab';\n          case Qt.ClosedHandCursor: return 'grabbing';\n          case Qt.DragCopyCursor: return 'copy';\n          case Qt.DragMoveCursor: return 'move';\n          case Qt.DragLinkCursor: return 'alias';\n          //case Qt.BitmapCursor: return 'auto';\n          //case Qt.CustomCursor: return 'auto';\n        }\n        return 'auto';\n    }\n\n    this.cursorShapeChanged.connect(function() {\n      self.dom.style.cursor = cursorShapeToCSS();\n    });\n  }\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'NumberAnimation',\n  versions: /.*/,\n  baseClass: 'PropertyAnimation',\n  constructor: function QMLNumberAnimation(meta) {\n    callSuper(this, meta);\n    var at = 0,\n        loop = 0,\n        self = this;\n\n    engine.$addTicker(ticker);\n\n    function ticker(now, elapsed) {\n        if ((self.running || loop === -1) && !self.paused) { // loop === -1 is a marker to just finish this run\n            if (at == 0 && loop == 0 && !self.$actions.length)\n                self.$redoActions();\n            at += elapsed / self.duration;\n            if (at >= 1)\n                self.complete();\n            else\n                for (var i in self.$actions) {\n                    var action = self.$actions[i],\n                        value = self.easing.$valueForProgress(at) * (action.to - action.from) + action.from;\n                    action.target.$properties[action.property].set(value, QMLProperty.ReasonAnimation);\n                }\n        }\n    }\n\n    function startLoop() {\n        for (var i in this.$actions) {\n            var action = this.$actions[i];\n            action.from = action.from !== undefined ? action.from : action.target[action.property];\n        }\n        at = 0;\n    }\n\n    this.runningChanged.connect(this, function(newVal) {\n        if (newVal) {\n            startLoop.call(this);\n            this.paused = false;\n        } else if (this.alwaysRunToEnd && at < 1) {\n            loop = -1; // -1 is used as a marker to stop\n        } else {\n            loop = 0;\n            this.$actions = [];\n        }\n    });\n\n    this.complete = function() {\n        for (var i in this.$actions) {\n            var action = this.$actions[i];\n            action.target.$properties[action.property].set(action.to, QMLProperty.ReasonAnimation);\n        }\n\n        if (++loop == this.loops)\n            this.running = false;\n        else if (!this.running)\n            this.$actions = [];\n        else\n            startLoop.call(this);\n    }\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'ParallelAnimation',\n  versions: /.*/,\n  baseClass: 'Animation',\n  constructor: function QMLParallelAnimation(meta) {\n    callSuper(this, meta);\n    var curIndex,\n        passedLoops,\n        i;\n\n    this.Animation = { Infinite: Math.Infinite }\n    createProperty(\"list\", this, \"animations\");\n    this.$defaultProperty = \"animations\";\n    this.$runningAnimations = 0;\n\n    this.animationsChanged.connect(this, function() {\n        for (i = 0; i < this.animations.length; i++) {\n            if (!this.animations[i].runningChanged.isConnected(this, animationFinished))\n                this.animations[i].runningChanged.connect(this, animationFinished);\n        }\n    });\n\n    function animationFinished(newVal) {\n        this.$runningAnimations += newVal ? 1 : -1;\n        if (this.$runningAnimations === 0)\n            this.running = false;\n    }\n\n    this.start = function() {\n        if (!this.running) {\n            this.running = true;\n            for (i = 0; i < this.animations.length; i++)\n                this.animations[i].start();\n        }\n    }\n    this.stop = function() {\n        if (this.running) {\n            for (i = 0; i < this.animations.length; i++)\n                this.animations[i].stop();\n            this.running = false;\n        }\n    }\n    this.complete = this.stop;\n\n    engine.$registerStart(function() {\n        if (self.running) {\n            self.running = false; // toggled back by start();\n            self.start();\n        }\n    });\n    engine.$registerStop(function() {\n        self.stop();\n    });\n  }\n});\n","function QMLPositioner(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"int\", this, \"spacing\");\n    this.spacingChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, this.layoutChildren);\n    this.childrenChanged.connect(this, QMLPositioner.slotChildrenChanged);\n\n    this.layoutChildren();\n}\n\nQMLPositioner.slotChildrenChanged = function() {\n    for (var i = 0; i < this.children.length; i++) {\n        var child = this.children[i];\n        if (!child.widthChanged.isConnected(this, this.layoutChildren))\n            child.widthChanged.connect(this, this.layoutChildren);\n        if (!child.heightChanged.isConnected(this, this.layoutChildren))\n            child.heightChanged.connect(this, this.layoutChildren);\n        if (!child.visibleChanged.isConnected(this, this.layoutChildren))\n            child.visibleChanged.connect(this, this.layoutChildren);\n    }\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name:   'Positioner',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLPositioner\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'PropertyAnimation',\n  versions: /.*/,\n  baseClass: 'Animation',\n  constructor: function QMLPropertyAnimation(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"int\", this, \"duration\", {initialValue: 250});\n    createProperty(\"real\", this, \"from\");\n    createProperty(\"string\", this, \"properties\");\n    createProperty(\"string\", this, \"property\");\n    createProperty(\"QtObject\", this, \"target\");\n    createProperty(\"list\", this, \"targets\");\n    createProperty(\"real\", this, \"to\");\n\n    this.easing = new QObject(this);\n    createProperty(\"enum\", this.easing, \"type\", {initialValue: Easing.Linear});\n    createProperty(\"real\", this.easing, \"amplitude\", {initialValue: 1});\n    createProperty(\"real\", this.easing, \"overshoot\", {initialValue: 0.3});\n    createProperty(\"real\", this.easing, \"period\", {initialValue: 1.70158});\n\n    this.easing.$valueForProgress = function(t) {\n        switch(this.type) {\n            // Quad\n            case Easing.InQuad: return Math.pow(t, 2);\n            case Easing.OutQuad: return -Math.pow(t - 1, 2) + 1;\n            case Easing.InOutQuad:\n                if (t < 0.5)\n                    return 2 * Math.pow(t, 2);\n                return -2 * Math.pow(t - 1, 2) + 1;\n            case Easing.OutInQuad:\n                if (t < 0.5)\n                    return -2 * Math.pow(t - 0.5, 2) + 0.5;\n                return 2 * Math.pow(t - 0.5, 2) + 0.5;\n            // Cubic\n            case Easing.InCubic: return Math.pow(t, 3);\n            case Easing.OutCubic: return Math.pow(t - 1, 3) + 1;\n            case Easing.InOutCubic:\n                if (t < 0.5)\n                    return 4 * Math.pow(t, 3);\n                return 4 * Math.pow(t - 1, 3) + 1;\n            case Easing.OutInCubic:\n                return 4 * Math.pow(t - 0.5, 3) + 0.5;\n            // Quart\n            case Easing.InQuart: return Math.pow(t, 4);\n            case Easing.OutQuart: return -Math.pow(t - 1, 4) + 1;\n            case Easing.InOutQuart:\n                if (t < 0.5)\n                    return 8 * Math.pow(t, 4);\n                return -8 * Math.pow(t - 1, 4) + 1;\n            case Easing.OutInQuart:\n                if (t < 0.5)\n                    return -8 * Math.pow(t - 0.5, 4) + 0.5;\n                return 8 * Math.pow(t - 0.5, 4) + 0.5;\n            // Quint\n            case Easing.InQuint: return Math.pow(t, 5);\n            case Easing.OutQuint: return Math.pow(t - 1, 5) + 1;\n            case Easing.InOutQuint:\n                if (t < 0.5)\n                    return 16 * Math.pow(t, 5);\n                return 16 * Math.pow(t - 1, 5) + 1;\n            case Easing.OutInQuint:\n                if (t < 0.5)\n                    return 16 * Math.pow(t - 0.5, 5) + 0.5;\n                return 16 * Math.pow(t - 0.5, 5) + 0.5;\n            // Sine\n            case Easing.InSine: return -Math.cos(0.5 * Math.PI * t) + 1;\n            case Easing.OutSine: return Math.sin(0.5 * Math.PI * t);\n            case Easing.InOutSine: return -0.5 * Math.cos(Math.PI * t) + 0.5;\n            case Easing.OutInSine:\n                if (t < 0.5)\n                    return 0.5 * Math.sin(Math.PI * t);\n                return -0.5 * Math.sin(Math.PI * t) + 1;\n            // Expo\n            case Easing.InExpo: return (1/1023) * (Math.pow(2, 10*t) - 1);\n            case Easing.OutExpo: return -(1024/1023) * (Math.pow(2, -10*t) - 1);\n            case Easing.InOutExpo:\n                if (t < 0.5)\n                    return (1/62) * (Math.pow(2, 10*t) - 1);\n                return -(512/31) * Math.pow(2, -10*t) + (63/62);\n            case Easing.OutInExpo:\n                if (t < 0.5)\n                    return -(16/31) * (Math.pow(2, -10*t) - 1);\n                return (1/1984) * Math.pow(2, 10*t) + (15/31);\n            // Circ\n            case Easing.InCirc: return 1 - Math.sqrt(1 - t*t);\n            case Easing.OutCirc: return Math.sqrt(1 - Math.pow(t - 1, 2));\n            case Easing.InOutCirc:\n                if (t < 0.5)\n                    return 0.5 * (1 - Math.sqrt(1 - 4*t*t));\n                return 0.5 * (Math.sqrt(1 - 4 * Math.pow(t - 1, 2)) + 1);\n            case Easing.OutInCirc:\n                if (t < 0.5)\n                    return 0.5 * Math.sqrt(1 - Math.pow(2 * t - 1, 2));\n                return 0.5 * (2 - Math.sqrt(1 - Math.pow(2 * t - 1, 2)));\n            // Elastic\n            case Easing.InElastic:\n                return -this.amplitude * Math.pow(2, 10 * t - 10)\n                        * Math.sin(2 * t * Math.PI / this.period - Math.asin(1 / this.amplitude));\n            case Easing.OutElastic:\n                return this.amplitude * Math.pow(2, -10 * t)\n                        * Math.sin(2 * t * Math.PI / this.period - Math.asin(1 / this.amplitude))\n                        + 1;\n            case Easing.InOutElastic:\n                if (t < 0.5)\n                    return -0.5 * this.amplitude * Math.pow(2, 20 * t - 10)\n                            * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude));\n                return -0.5 * this.amplitude * Math.pow(2, -20 * t + 10)\n                        * Math.sin(4 * t * Math.PI / this.period + Math.asin(1 / this.amplitude))\n                        + 1;\n            case Easing.OutInElastic:\n                if (t < 0.5)\n                    return 0.5 * this.amplitude * Math.pow(2, -20 * t)\n                            * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude))\n                            + 0.5;\n                return -0.5 * this.amplitude * Math.pow(2, 20 * t - 20)\n                        * Math.sin(4 * t * Math.PI / this.period - Math.asin(1 / this.amplitude))\n                        + 0.5;\n            // Back\n            case Easing.InBack: return (this.overshoot + 1) * Math.pow(t, 3) - this.overshoot * Math.pow(t, 2);\n            case Easing.OutBack: return (this.overshoot + 1) * Math.pow(t - 1, 3) + this.overshoot * Math.pow(t - 1, 2) + 1;\n            case Easing.InOutBack:\n                if (t < 0.5)\n                    return 4 * (this.overshoot + 1) * Math.pow(t, 3) - 2 * this.overshoot * Math.pow(t, 2);\n                return 0.5 * (this.overshoot + 1) * Math.pow(2 * t - 2, 3) + this.overshoot/2 * Math.pow(2 * t - 2, 2) + 1;\n            case Easing.OutInBack:\n                if (t < 0.5)\n                    return 0.5 * ((this.overshoot + 1) * Math.pow(2 * t - 1, 3) + this.overshoot * Math.pow(2 * t - 1, 2) + 1);\n                return 4 * (this.overshoot + 1) * Math.pow( t - 0.5, 3) - 2 * this.overshoot * Math.pow(t - 0.5, 2) + 0.5;\n            // Bounce\n            case Easing.InBounce:\n                if (t < 1/11) return -this.amplitude * (121/16) * (t*t - (1/11)*t);\n                if (t < 3/11) return -this.amplitude * (121/16) * (t*t - (4/11)*t + (3/121));\n                if (t < 7/11) return -this.amplitude * (121/16) * (t*t - (10/11)*t + (21/121));\n                return -(121/16) * (t*t - 2*t + 1) + 1;\n            case Easing.OutBounce:\n                if (t < 4/11) return (121/16) * t*t;\n                if (t < 8/11) return this.amplitude * (121/16) * (t*t - (12/11)*t + (32/121)) + 1;\n                if (t < 10/11) return this.amplitude * (121/16) * (t*t - (18/11)*t + (80/121)) + 1;\n                return this.amplitude * (121/16) * (t*t - (21/11)*t + (10/11)) + 1;\n            case Easing.InOutBounce:\n                if (t < 1/22) return -this.amplitude * (121/8) * (t*t - (1/22)*t);\n                if (t < 3/22) return -this.amplitude * (121/8) * (t*t - (2/11)*t + (3/484));\n                if (t < 7/22) return -this.amplitude * (121/8) * (t*t - (5/11)*t + (21/484));\n                if (t < 11/22) return -(121/8) * (t*t - t + 0.25) + 0.5;\n                if (t < 15/22) return (121/8) * (t*t - t) + (137/32);\n                if (t < 19/22) return this.amplitude * (121/8) * (t*t - (17/11)*t + (285/484)) + 1;\n                if (t < 21/22) return this.amplitude * (121/8) * (t*t - (20/11)*t + (399/484)) + 1;\n                return this.amplitude * (121/8) * (t*t - (43/22)*t + (21/22)) + 1;\n            case Easing.OutInBounce:\n                if (t < 4/22) return (121/8) * t*t;\n                if (t < 8/22) return -this.amplitude * (121/8) * (t*t - (6/11)*t + (8/121)) + 0.5;\n                if (t < 10/22) return -this.amplitude * (121/8) * (t*t - (9/11)*t + (20/121)) + 0.5;\n                if (t < 11/22) return -this.amplitude * (121/8) * (t*t - (21/22)*t + (5/22)) + 0.5;\n                if (t < 12/22) return this.amplitude * (121/8) * (t*t - (23/22)*t + (3/11)) + 0.5;\n                if (t < 14/22) return this.amplitude * (121/8) * (t*t - (13/11)*t + (42/121)) + 0.5;\n                if (t < 18/22) return this.amplitude * (121/8) * (t*t - (16/11)*t + (63/121)) + 0.5;\n                return -(121/8) * (t*t - 2*t + (117/121)) + 0.5;\n            // Default\n            default:\n                console.log(\"Unsupported animation type: \", this.type);\n            // Linear\n            case Easing.Linear:\n                return t;\n        }\n    }\n\n    this.$redoActions = function() {\n        this.$actions = [];\n        for (var i = 0; i < this.$targets.length; i++) {\n            for (var j in this.$props) {\n                this.$actions.push({\n                    target: this.$targets[i],\n                    property: this.$props[j],\n                    from: this.from,\n                    to: this.to\n                });\n            }\n        }\n    }\n    function redoProperties() {\n        this.$props = this.properties.split(\",\");\n\n        // Remove whitespaces\n        for (var i = 0; i < this.$props.length; i++) {\n            var matches = this.$props[i].match(/\\w+/);\n            if (matches) {\n                this.$props[i] = matches[0];\n            } else {\n                this.$props.splice(i, 1);\n                i--;\n            }\n        }\n        // Merge properties and property\n        if (this.property && this.$props.indexOf(this.property) === -1)\n            this.$props.push(this.property);\n    }\n    function redoTargets() {\n        this.$targets = this.targets.slice();\n\n        if (this.target && this.$targets.indexOf(this.target) === -1)\n            this.$targets.push(this.target);\n    }\n\n    this.duration = 250;\n    this.easing.type = Easing.Linear;\n    this.easing.amplitude = 1;\n    this.easing.period = 0.3;\n    this.easing.overshoot = 1.70158;\n    this.$props = [];\n    this.$targets = [];\n    this.$actions = [];\n    this.properties = \"\";\n    this.targets = [];\n\n    this.targetChanged.connect(this, redoTargets);\n    this.targetsChanged.connect(this, redoTargets);\n    this.propertyChanged.connect(this, redoProperties);\n    this.propertiesChanged.connect(this, redoProperties);\n\n    if (meta.object.$on !== undefined) {\n        this.property = meta.object.$on;\n        this.target = this.$parent;\n    }\n  }\n});\n\n","function QMLPropertyChanges(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"QtObject\", this, \"target\");\n    createProperty(\"bool\", this, \"explicit\");\n    createProperty(\"bool\", this, \"restoreEntryValues\", {initialValue: true});\n\n    this.$actions = [];\n\n    this.$setCustomData = function(propName, value) {\n        this.$actions.push({\n            property: propName,\n            value: value\n        });\n    }\n}\n\nregisterQmlType({\n  module: 'QtQuick',\n  name: 'PropertyChanges',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: QMLPropertyChanges\n});\n","// Base object for all qml elements\nfunction QMLBaseObject(meta) {\n    QObject.call(this, meta.parent);\n    var i,\n        prop;\n\n    this.$isComponentRoot = meta.isComponentRoot;\n    this.$context = meta.context;\n\n    // Component get own properties\n    var attributes = [];\n    for (var key in meta.object) {\n      if (meta.object.hasOwnProperty(key) &&\n          typeof meta.object[key] != 'undefined' && meta.object[key] != null &&\n          (meta.object[key].__proto__.constructor.name == 'QMLPropertyDefinition' ||\n           meta.object[key].__proto__.constructor.name == 'QMLAliasDefinition')) {\n        attributes.push(key);\n      }\n    }\n\n    this.Keys = new QObject(this);\n    this.Keys.asteriskPresed = Signal();\n    this.Keys.backPressed = Signal();\n    this.Keys.backtabPressed = Signal();\n    this.Keys.callPressed = Signal();\n    this.Keys.cancelPressed = Signal();\n    this.Keys.deletePressed = Signal();\n    for (var i = 0 ; i < 10 ; ++i)\n      this.Keys['digit'+i+'Pressed'] = Signal();\n    this.Keys.escapePressed = Signal();\n    this.Keys.flipPressed = Signal();\n    this.Keys.hangupPressed = Signal();\n    this.Keys.leftPressed = Signal();\n    this.Keys.menuPressed = Signal();\n    this.Keys.noPressed = Signal();\n    this.Keys.pressed = Signal();\n    this.Keys.released = Signal();\n    this.Keys.returnPressed = Signal();\n    this.Keys.rightPressed = Signal();\n    this.Keys.selectPressed = Signal();\n    this.Keys.spacePressed = Signal();\n    this.Keys.tabPressed = Signal();\n    this.Keys.upPressed = Signal();\n    this.Keys.volumeDownPressed = Signal();\n    this.Keys.volumeUpPressed = Signal();\n    this.Keys.yesPressed = Signal();\n\n    this.getAttributes = function() { return (attributes); }\n}\n\nregisterQmlType({\n    module: 'QtQuick',\n    name: 'QtObject',\n    versions: /.*/,\n    constructor: QMLBaseObject\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Rectangle',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLRectangle(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"color\", this, \"color\", {initialValue: 'white'});\n    createProperty(\"real\", this, \"radius\");\n\n    this.border = new QObject(this);\n    createProperty(\"color\", this.border, \"color\", {initialValue: 'black'});\n    createProperty(\"int\", this.border, \"width\", {initialValue: 1});\n\n    const bg = this.impl = document.createElement('div');\n    bg.style.pointerEvents = 'none';\n    bg.style.position = 'absolute';\n    bg.style.left = bg.style.right = bg.style.top = bg.style.bottom = '0px';\n    bg.style.borderWidth ='0px';\n    bg.style.borderStyle = 'solid';\n    bg.style.borderColor = 'black';\n    bg.style.backgroundColor = 'white';\n    this.dom.appendChild(bg);\n\n    this.colorChanged.connect(this, function(newVal) {\n        bg.style.backgroundColor = QMLColor(newVal);\n    });\n    this.radiusChanged.connect(this, function(newVal) {\n        bg.style.borderRadius = newVal + 'px';\n    });\n    this.border.colorChanged.connect(this, function(newVal) {\n        bg.style.borderColor = QMLColor(newVal);\n        bg.style.borderWidth = this.border.width + 'px';\n    });\n    this.border.widthChanged.connect(this, function(newVal) {\n        bg.style.borderWidth = newVal + 'px';\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'RegExpValidator',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLRegExpValidator(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"var\", this, \"regExp\");\n\n    this.validate = (function(string) {\n      if (typeof this.regExp == 'undefined' || this.regExp == null)\n        return true;\n      return this.regExp.test(string);\n    }).bind(this);\n  }\n});\n","function QMLRepeater(meta) {\n    callSuper(this, meta);\n    var self = this;\n    var QMLListModel = getConstructor('QtQuick', '2.0', 'ListModel');\n\n    createProperty(\"Component\", this, \"delegate\");\n    this.container = function() { return this.parent; }\n    this.$defaultProperty = \"delegate\";\n    createProperty(\"variant\", this, \"model\", {initialValue: 0});\n    createProperty(\"int\", this, \"count\");\n    this.$completed = false;\n    this.$items = []; // List of created items\n    this._childrenInserted = Signal();\n\n    this.modelChanged.connect(applyModel);\n    this.delegateChanged.connect(applyModel);\n    this.parentChanged.connect(applyModel);\n\n    this.itemAt = function(index) {\n        return this.$items[index];\n    }\n\n    function callOnCompleted(child) {\n        child.Component.completed();\n        for (var i = 0; i < child.$tidyupList.length; i++)\n            if (child.$tidyupList[i] instanceof QMLBaseObject)\n                callOnCompleted(child.$tidyupList[i]);\n    }\n    function insertChildren(startIndex, endIndex) {\n        for (var index = startIndex; index < endIndex; index++) {\n            var newItem = self.delegate.createObject(self);\n\n            createProperty(\"int\", newItem, \"index\");\n            var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n            for (var i in model.roleNames) {\n                if (typeof newItem.$properties[model.roleNames[i]] == 'undefined')\n                  createProperty(\"variant\", newItem, model.roleNames[i]);\n                newItem.$properties[model.roleNames[i]].set(model.data(index, model.roleNames[i]), QMLProperty.ReasonInit, newItem, self.model.$context);\n            }\n\n            self.container().children.splice(self.parent.children.indexOf(self) - self.$items.length + index, 0, newItem);\n            newItem.parent = self.container();\n            self.container().childrenChanged();\n            self.$items.splice(index, 0, newItem);\n\n            newItem.index = index;\n\n            // TODO debug this. Without check to Init, Completed sometimes called twice.. But is this check correct?\n            if (engine.operationState !== QMLOperationState.Init && engine.operationState !== QMLOperationState.Idle) {\n                // We don't call those on first creation, as they will be called\n                // by the regular creation-procedures at the right time.\n                engine.$initializePropertyBindings();\n                callOnCompleted(newItem);\n            }\n        }\n        for (var i = endIndex; i < self.$items.length; i++)\n            self.$items[i].index = i;\n\n        self.count = self.$items.length;\n    }\n\n    function applyModel() {\n        if (!self.delegate || !self.parent)\n            return;\n        var model = self.model instanceof QMLListModel ? self.model.$model : self.model;\n        if (model instanceof JSItemModel) {\n            model.dataChanged.connect(function(startIndex, endIndex, roles) {\n                if (!roles)\n                    roles = model.roleNames;\n                for (var index = startIndex; index <= endIndex; index++) {\n                    for (var i in roles) {\n                        self.$items[index].$properties[roles[i]].set(model.data(index, roles[i]), QMLProperty.ReasonInit, self.$items[index], self.model.$context);\n                    }\n                }\n            });\n            model.rowsInserted.connect(insertChildren);\n            model.rowsMoved.connect(function(sourceStartIndex, sourceEndIndex, destinationIndex) {\n                var vals = self.$items.splice(sourceStartIndex, sourceEndIndex-sourceStartIndex);\n                for (var i = 0; i < vals.length; i++) {\n                    self.$items.splice(destinationIndex + i, 0, vals[i]);\n                }\n                var smallestChangedIndex = sourceStartIndex < destinationIndex\n                                        ? sourceStartIndex : destinationIndex;\n                for (var i = smallestChangedIndex; i < self.$items.length; i++) {\n                    self.$items[i].index = i;\n                }\n            });\n            model.rowsRemoved.connect(function(startIndex, endIndex) {\n                removeChildren(startIndex, endIndex);\n                for (var i = startIndex; i < self.$items.length; i++) {\n                    self.$items[i].index = i;\n                }\n                self.count = self.$items.length;\n            });\n            model.modelReset.connect(function() {\n                removeChildren(0, self.$items.length);\n                insertChildren(0, model.rowCount());\n            });\n\n            insertChildren(0, model.rowCount());\n        } else if (typeof model == \"number\") {\n            // must be more elegant here.. do not delete already created models..\n            //removeChildren(0, self.$items.length);\n            //insertChildren(0, model);\n\n            if (self.$items.length > model) {\n               // have more than we need\n               removeChildren(model,self.$items.length);\n            }\n            else\n            {\n               // need more\n               insertChildren(self.$items.length,model);\n            }\n\n        }\n    }\n\n    function removeChildren(startIndex, endIndex) {\n        var removed = self.$items.splice(startIndex, endIndex - startIndex);\n        for (var index in removed) {\n            removed[index].$delete();\n            removeChildProperties(removed[index]);\n        }\n    }\n    function removeChildProperties(child) {\n        engine.completedSignals.splice(engine.completedSignals.indexOf(child.Component.completed), 1);\n        for (var i = 0; i < child.children.length; i++)\n            removeChildProperties(child.children[i])\n    }\n}\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'Repeater',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLRepeater\n});\n","registerQmlType({\n  module: 'QtQuick',\n  name:   'Rotation',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLRotation(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"angle\");\n\n    this.axis = new QObject(this);\n    createProperty(\"real\", this.axis, \"x\");\n    createProperty(\"real\", this.axis, \"y\");\n    createProperty(\"real\", this.axis, \"z\", {initialValue: 1});\n\n    this.origin = new QObject(this);\n    createProperty(\"real\", this.origin, \"x\");\n    createProperty(\"real\", this.origin, \"y\");\n\n    function updateOrigin() {\n        this.$parent.dom.style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n        this.$parent.dom.style.MozTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";    // Firefox\n        this.$parent.dom.style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\"; // Chrome, Safari and Opera\n    }\n    this.angleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.axis.zChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, updateOrigin);\n    this.origin.yChanged.connect(this, updateOrigin);\n    this.$parent.$updateTransform();\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Row',\n  versions: /.*/,\n  baseClass: 'Positioner',\n  constructor: QMLRow\n});\n\nfunction QMLRow(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"enum\", this, \"layoutDirection\", {initialValue: 0});\n    this.layoutDirectionChanged.connect(this, this.layoutChildren);\n    this.layoutChildren();\n}\n\nQMLRow.prototype.layoutChildren = function() {\n    var curPos = 0,\n        maxHeight = 0,\n        // When layoutDirection is RightToLeft we need oposite order\n        i = this.layoutDirection == 1 ? this.children.length - 1 : 0,\n        endPoint = this.layoutDirection == 1 ? -1 : this.children.length,\n        step = this.layoutDirection == 1 ? -1 : 1;\n    for (; i !== endPoint; i += step) {\n        var child = this.children[i];\n        if (!(child.visible && child.width && child.height))\n            continue;\n        maxHeight = child.height > maxHeight ? child.height : maxHeight;\n\n        child.x = curPos;\n        curPos += child.width + this.spacing;\n    }\n    this.implicitHeight = maxHeight;\n    this.implicitWidth = curPos - this.spacing; // We want no spacing at the right side\n}\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Scale',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLScale(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"xScale\");\n    createProperty(\"real\", this, \"yScale\");\n\n    this.origin = new QObject(this);\n    createProperty(\"real\", this.origin, \"x\");\n    createProperty(\"real\", this.origin, \"y\");\n\n    function updateOrigin() {\n        this.$parent.dom.style.transformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";\n        this.$parent.dom.style.MozTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\";    // Firefox\n        this.$parent.dom.style.webkitTransformOrigin = this.origin.x + \"px \" + this.origin.y + \"px\"; // Chrome, Safari and Opera\n    }\n    this.xScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yScaleChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.origin.xChanged.connect(this, updateOrigin);\n    this.origin.yChanged.connect(this, updateOrigin);\n\n    this.xScale = 0;\n    this.yScale = 0;\n    this.origin.x = 0;\n    this.origin.y = 0;\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'SequentialAnimation',\n  versions: /.*/,\n  baseClass: 'Animation',\n  constructor: function QMLSequentialAnimation(meta) {\n    callSuper(this, meta);\n    var curIndex,\n        passedLoops,\n        i,\n        self = this;\n\n    createProperty(\"list\", this, \"animations\");\n    this.$defaultProperty = \"animations\";\n\n    function nextAnimation(proceed) {\n        var anim;\n        if (self.running && !proceed) {\n            curIndex++;\n            if (curIndex < self.animations.length) {\n                anim = self.animations[curIndex];\n                console.log(\"nextAnimation\", self, curIndex, anim);\n                anim.start();\n            } else {\n                passedLoops++;\n                if (passedLoops >= self.loops) {\n                    self.complete();\n                } else {\n                    curIndex = -1;\n                    nextAnimation();\n                }\n            }\n        }\n    }\n\n    this.animationsChanged.connect(this, function() {\n        for (i = 0; i < this.animations.length; i++) {\n            if (!this.animations[i].runningChanged.isConnected(nextAnimation))\n                this.animations[i].runningChanged.connect(nextAnimation);\n        }\n    });\n\n    this.start = function() {\n        if (!this.running) {\n            this.running = true;\n            curIndex = -1;\n            passedLoops = 0;\n            nextAnimation();\n        }\n    }\n    this.stop = function() {\n        if (this.running) {\n            this.running = false;\n            if (curIndex < this.animations.length) {\n                this.animations[curIndex].stop();\n            }\n        }\n    }\n\n    this.complete = function() {\n        if (this.running) {\n            if (curIndex < this.animations.length) {\n                // Stop current animation\n                this.animations[curIndex].stop();\n            }\n            this.running = false;\n        }\n    }\n\n    engine.$registerStart(function() {\n        if (self.running) {\n            self.running = false; // toggled back by start();\n            self.start();\n        }\n    });\n    engine.$registerStop(function() {\n        self.stop();\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'State',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLState(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"string\", this, \"name\");\n    createProperty(\"list\", this, \"changes\");\n    this.$defaultProperty = \"changes\";\n    createProperty(\"string\", this, \"extend\");\n    createProperty(\"bool\", this, \"when\");\n    this.$item = this.$parent;\n\n    this.whenChanged.connect(this, function(newVal) {\n        if (newVal)\n            this.$item.state = this.name;\n        else if (this.$item.state == this.name)\n            this.$item.state = \"\";\n    });\n\n    this.$getAllChanges = function() {\n        if (this.extend) {\n            for (var i = 0; i < this.$item.states.length; i++)\n                if (this.$item.states[i].name == this.extend)\n                    return this.$item.states[i].$getAllChanges().concat(this.changes);\n        } else\n            return this.changes;\n    }\n  }\n});\n","window.SystemPalette = {\n  Active:   \"active\",\n  Inactive: \"inactive\",\n  Disabled: \"disabled\"\n};\n\nwindow.platformsDetectors = [\n  //{ name: 'W8',      regexp: /Windows NT 6\\.2/ },\n  //{ name: 'W7',      regexp: /Windows NT 6\\.1/ },\n  //{ name: 'Windows', regexp: /Windows NT/ },\n  { name: 'OSX',     regexp: /Macintosh/ }\n];\n\nwindow.systemPalettes = {};\n\nregisterQmlType({\n  module: 'QtQuick',\n  name: 'SystemPalette',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLSystemPalette(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"enum\", this, \"colorGroup\");\n\n    var attrs    = [ 'alternateBase', 'base', 'button', 'buttonText', 'dark', 'highlight', 'highlightedText', 'light', 'mid', 'midlight', 'shadow', 'text', 'window', 'windowText' ];\n    var platform = 'OSX';\n\n    for (var i = 0 ; i < attrs.length ; ++i)\n      createProperty(\"color\", this, attrs[i], { readOnly: true });\n    createProperty(\"enum\", this, \"colorGroup\");\n\n    this.colorGroupChanged.connect(this, (function (newVal) {\n      this.$canEditReadOnlyProperties = true;\n      for (var i = 0 ; i < attrs.length ; ++i) {\n        this[attrs[i]] = systemPalettes[platform][newVal][attrs[i]];\n      }\n      delete this.$canEditReadOnlyProperties;\n    }).bind(this));\n\n    // Detect OS\n    for (var i = 0 ; i < platformsDetectors.length ; ++i) {\n      if (platformsDetectors[i].regexp.test(navigator.userAgent)) {\n        platforms = platformsDetectors[i].name;\n        break ;\n      }\n    }\n  }\n});\n\nwindow.systemPalettes['OSX'] = {\n        'active': {\n          'alternateBase': '#f6f6f6',\n          'base':          '#ffffff',\n          'button':        '#ededed',\n          'buttonText':    '#000000',\n          'dark':          '#bfbfbf',\n          'highlight':     '#fbed73',\n          'highlightText': '#000000',\n          'light':         '#ffffff',\n          'mid':           '#a9a9a9',\n          'midlight':      '#f6f6f6',\n          'shadow':        '#8b8b8b',\n          'text':          '#000000',\n          'window':        '#ededed',\n          'windowText':    '#000000'\n        },\n        'inactive': {\n          'alternateBase': '#f6f6f6',\n          'base':          '#ffffff',\n          'button':        '#ededed',\n          'buttonText':    '#000000',\n          'dark':          '#bfbfbf',\n          'highlight':     '#d0d0d0',\n          'highlightText': '#000000',\n          'light':         '#ffffff',\n          'mid':           '#a9a9a9',\n          'midlight':      '#f6f6f6',\n          'shadow':        '#8b8b8b',\n          'text':          '#000000',\n          'window':        '#ededed',\n          'windowText':    '#000000'\n        },\n        'disabled': {\n          'alternateBase': '#f6f6f6',\n          'base':          '#ededed',\n          'button':        '#ededed',\n          'buttonText':    '#949494',\n          'dark':          '#bfbfbf',\n          'highlight':     '#d0d0d0',\n          'highlightText': '#7f7f7f',\n          'light':         '#ffffff',\n          'mid':           '#a9a9a9',\n          'midlight':      '#f6f6f6',\n          'shadow':        '#8b8b8b',\n          'text':          '#7f7f7f',\n          'window':        '#ededed',\n          'windowText':    '#7f7f7f'\n        }\n};\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Text',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLText(meta) {\n    callSuper(this, meta);\n\n    const fc = this.impl = document.createElement('span');\n    fc.style.pointerEvents = 'none';\n    fc.style.width = '100%';\n    fc.style.height = '100%';\n    this.dom.appendChild(fc);\n\n    this.Text = {\n        // Wrap Mode\n        NoWrap: 0,\n        WordWrap: 1,\n        WrapAnywhere: 2,\n        Wrap: 3,\n        WrapAtWordBoundaryOrAnywhere: 3, // COMPAT\n        // Horizontal-Alignment\n        AlignLeft: \"left\",\n        AlignRight: \"right\",\n        AlignHCenter: \"center\",\n        AlignJustify: \"justify\",\n        // Style\n        Normal: 0,\n        Outline: 1,\n        Raised: 2,\n        Sunken: 3\n    }\n\n    var QMLFont = new getConstructor('QtQuick', '2.0', 'Font');\n    this.font   = new QMLFont(this);\n\n    createProperty(\"color\", this, \"color\");\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"real\", this, \"lineHeight\");\n    createProperty(\"enum\", this, \"wrapMode\");\n    createProperty(\"enum\", this, \"horizontalAlignment\");\n    createProperty(\"enum\", this, \"style\");\n    createProperty(\"color\", this, \"styleColor\");\n\n    this.colorChanged.connect(this, function(newVal) {\n        fc.style.color = QMLColor(newVal);\n    });\n    this.textChanged.connect(this, function(newVal) {\n        fc.innerHTML = newVal;\n    });\n    this.lineHeightChanged.connect(this, function(newVal) {\n        fc.style.lineHeight = newVal + \"px\";\n    });\n    this.wrapModeChanged.connect(this, function(newVal) {\n        switch (newVal) {\n            case 0:\n                fc.style.whiteSpace = \"pre\";\n                break;\n            case 1:\n                fc.style.whiteSpace = \"pre-wrap\";\n                fc.style.wordWrap = \"normal\";\n                break;\n            case 2:\n                fc.style.whiteSpace = \"pre-wrap\";\n                fc.style.wordBreak = \"break-all\";\n                break;\n            case 3:\n                fc.style.whiteSpace = \"pre-wrap\";\n                fc.style.wordWrap = \"break-word\";\n        };\n        // AlignJustify doesn't work with pre/pre-wrap, so we decide the\n        // lesser of the two evils to be ignoring \"\\n\"s inside the text.\n        if (this.horizontalAlignment == \"justify\")\n            fc.style.whiteSpace = \"normal\";\n    });\n    this.horizontalAlignmentChanged.connect(this, function(newVal) {\n        this.dom.style.textAlign = newVal;\n        // AlignJustify doesn't work with pre/pre-wrap, so we decide the\n        // lesser of the two evils to be ignoring \"\\n\"s inside the text.\n        if (newVal == \"justify\")\n            fc.style.whiteSpace = \"normal\";\n    });\n    this.styleChanged.connect(this, function(newVal) {\n        switch (newVal) {\n            case 0:\n                fc.style.textShadow = \"none\";\n                break;\n            case 1:\n                var color = this.styleColor;\n                fc.style.textShadow = \"1px 0 0 \" + color\n                    + \", -1px 0 0 \" + color\n                    + \", 0 1px 0 \" + color\n                    + \", 0 -1px 0 \" + color;\n                break;\n            case 2:\n                fc.style.textShadow = \"1px 1px 0 \" + this.styleColor;\n                break;\n            case 3:\n                fc.style.textShadow = \"-1px -1px 0 \" + this.styleColor;\n        };\n    });\n    this.styleColorChanged.connect(this, function(newVal) {\n        newVal = QMLColor(newVal);\n        switch (this.style) {\n            case 0:\n                fc.style.textShadow = \"none\";\n                break;\n            case 1:\n                fc.style.textShadow = \"1px 0 0 \" + newVal\n                    + \", -1px 0 0 \" + newVal\n                    + \", 0 1px 0 \" + newVal\n                    + \", 0 -1px 0 \" + newVal;\n                break;\n            case 2:\n                fc.style.textShadow = \"1px 1px 0 \" + newVal;\n                break;\n            case 3:\n                fc.style.textShadow = \"-1px -1px 0 \" + newVal;\n        };\n    });\n\n    this.font.family = \"sans-serif\";\n    this.font.pointSize = 10;\n    this.wrapMode = this.Text.NoWrap;\n    this.color = \"black\";\n    this.text = \"\";\n\n    this.textChanged.connect(this, updateImplicit);\n    this.font.boldChanged.connect(this, updateImplicit);\n    this.font.pixelSizeChanged.connect(this, updateImplicit);\n    this.font.pointSizeChanged.connect(this, updateImplicit);\n    this.font.familyChanged.connect(this, updateImplicit);\n    this.font.letterSpacingChanged.connect(this, updateImplicit);\n    this.font.wordSpacingChanged.connect(this, updateImplicit);\n\n    this.Component.completed.connect(this, updateImplicit);\n\n    function updateImplicit() {\n        if (typeof this.text == undefined || this.text === \"\" || !this.dom) {\n             this.implicitHeigh = this.implicitWidth = 0;\n        } else {\n            this.implicitHeight = fc.offsetHeight;\n            this.implicitWidth = fc.offsetWidth;\n        }\n    }\n  }\n});\n","function QMLTextEdit(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    // Properties\n    createProperty('bool', this, 'activeFocusOnPress');\n    createProperty('url', this, 'baseUrl');\n    createProperty('bool', this, 'canPaste');\n    createProperty('bool', this, 'canRedo');\n    createProperty('bool', this, 'canUndo');\n    createProperty('color', this, 'color');\n    createProperty('real', this, 'contentHeight');\n    createProperty('real', this, 'contentWidth');\n    createProperty('Component', this, 'cursorDelegate');\n    createProperty('int', this, 'cursorPosition');\n    createProperty('rectangle', this, 'cursorRectangle');\n    createProperty('bool', this, 'cursorVisible');\n    createProperty('enum', this, 'effectiveHorizontalAlignment');\n    createProperty('enum', this, 'horizontalAlignment');\n    createProperty('string', this, 'hoveredLink');\n    createProperty('bool', this, 'inputMethodComposing');\n    createProperty('enum', this, 'inputMethodHints');\n    createProperty('int', this, 'length');\n    createProperty('int', this, 'lineCount');\n    createProperty('enum', this, 'mouseSelectionMode');\n    createProperty('bool', this, 'persistentSelection');\n    createProperty('bool', this, 'readOnly');\n    createProperty('enum', this, 'renderType');\n    createProperty('bool', this, 'selectByKeyboard');\n    createProperty('bool', this, 'selectByMouse');\n    createProperty('string', this, 'selectedText');\n    createProperty('color', this, 'selectedTextColor');\n    createProperty('color', this, 'selectionColor');\n    createProperty('int', this, 'selectionEnd');\n    createProperty('int', this, 'selectionStart');\n    createProperty('string', this, 'text');\n    createProperty('TextDocument', this, 'textDocument');\n    createProperty('enum', this, 'textFormat');\n    createProperty('real', this, 'textMargin');\n    createProperty('enum', this, 'verticalAlignment');\n    createProperty('enum', this, 'wrapMode');\n\n    var QMLFont = new getConstructor('QtQuick', '2.0', 'Font');\n    this.font = new QMLFont(this);\n\n    this.activeFocusOnPress = true;\n    this.baseUrl = undefined;\n    this.canPaste = false;\n    this.canRedo = false;\n    this.canUndo = false;\n    this.color = 'white';\n    this.contentHeight = 0;\n    this.contentWidth = 0;\n    this.cursorDelegate = undefined;\n    this.cursorPosition = 0;\n    this.cursorRectangle = undefined;\n    this.cursorVisible = true;\n    this.effectiveHorizontalAlignment = undefined;\n    this.horizontalAlignment = undefined;\n    this.hoveredLink = undefined;\n    this.inputMethodComposing = undefined;\n    this.inputMethodHints = undefined;\n    this.length = 0;\n    this.lineCount = 0;\n    this.mouseSelectionMode = undefined;\n    this.persistentSelection = false;\n    this.readOnly = false;\n    this.renderType = undefined;\n    this.selectByKeyboard = true;\n    this.selectByMouse = false;\n    this.selectedText = undefined;\n    this.selectedTextColor = 'yellow';\n    this.selectionColor = 'pink';\n    this.selectionEnd = 0;\n    this.selectionStart = 0;\n    this.text = '';\n    this.textDocument = undefined;\n    this.textFormat = undefined;\n    this.textMargin = 0;\n    this.verticalAlignment = undefined;\n    this.wrapMode = undefined;\n\n    // Undo / Redo stacks;\n    this.undoStack = [];\n    this.undoStackPosition = -1;\n    this.redoStack = [];\n    this.redoStackPosition = -1;\n\n    const textarea = this.impl = document.createElement('textarea');\n    textarea.style.pointerEvents = \"auto\";\n    textarea.style.width = \"100%\";\n    textarea.style.height = \"100%\";\n    textarea.style.boxSizing = 'border-box';\n    textarea.style.borderWidth = '0';\n    textarea.style.background = 'none';\n    textarea.style.outline = 'none';\n    textarea.style.resize = 'none';\n    textarea.style.padding = '0'; // TODO: padding/*Padding props from Qt 5.6\n    // In some browsers text-areas have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    textarea.style.margin = \"0\";\n    textarea.disabled = false;\n    this.dom.appendChild(textarea);\n\n    this.Component.completed.connect(this, function() {\n        this.implicitWidth = textarea.offsetWidth;\n        this.implicitHeight = textarea.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function(newVal) {\n        textarea.value = newVal;\n    });\n\n    // Signals\n    this.linkActivated = Signal([{\n        type: 'string',\n        name: 'link'\n    }]);\n    this.linkHovered = Signal([{\n        type: 'string',\n        name: 'link'\n    }]);\n\n    // Methods\n    this.append = function append(text) {\n        this.text += text;\n    };\n\n    this.copy = function copy() {\n        // TODO\n    };\n\n    this.cut = function cut() {\n        this.text =\n            this.text(0, this.selectionStart) + this.text(this.selectionEnd, this.text.length);\n        // TODO\n    };\n\n    this.deselect = function deselect() {\n        //this.selectionStart = -1;\n        //this.selectionEnd = -1;\n        //this.selectedText = null;\n    };\n\n    this.getFormattedText = function getFormattedText(start, end) {\n        this.text = this.text.slice(start, end);\n        // TODO\n        // process text\n        return text;\n    };\n\n    this.getText = function getText(start, end) {\n        return this.text.slice(start, end);\n    };\n\n    this.insert = function getText(position, text) {\n        // TODO\n    };\n\n    this.isRightToLeft = function isRightToLeft(start, end) {\n        // TODO\n    };\n\n    this.linkAt = function linkAt(x, y) {\n        // TODO\n    };\n\n    this.moveCursorSelection = function moveCursorSelection(x, y) {\n        // TODO\n    };\n\n    this.paste = function paste() {\n        // TODO\n    };\n\n    this.positionAt = function positionAt(x, y) {\n        // TODO\n    };\n\n    this.positionToRectangle = function positionToRectangle(position) {\n        // TODO\n    };\n\n    this.redo = function redo() {\n        // TODO\n    };\n\n    this.remove = function remove(start, end) {\n        // TODO\n    };\n\n    this.select = function select(start, end) {\n        // TODO\n    };\n\n    this.selectAll = function selectAll() {\n        // TODO\n    };\n\n    this.selectWord = function selectWord() {\n        // TODO\n    };\n\n    this.undo = function undo() {\n        // TODO\n    };\n\n    var getLineCount = function(self) {\n        return self.text.split(/\\n/).length;\n    }\n\n    this.Component.completed.connect(this, function() {\n        this.selectByKeyboard = !this.readOnly;\n        updateValue();\n    });\n\n    // Transfer dom style to firstChild,\n    // then clear corresponding dom style\n    function updateCss(self) {\n        var supported = [\n            'border',\n            'borderRadius',\n            'borderWidth',\n            'borderColor',\n            'backgroundColor',\n        ];\n\n        var child_style = self.dom.firstChild.style;\n        for (n = 0; n < supported.length; n++) {\n            var o = supported[n];\n            var v = self.css[o];\n            if (v) {\n                child_style[o] = v;\n                self.css[o] = null;\n            }\n        }\n    }\n\n    function updateValue(e) {\n        if (self.text != self.dom.firstChild.value) {\n            self.text = self.dom.firstChild.value;\n        }\n        self.length = self.text.length;\n        self.lineCount = getLineCount(self);\n        updateCss(self);\n    }\n\n    textarea.oninput = updateValue;\n    textarea.onpropertychanged = updateValue;\n\n    this.colorChanged.connect(this, function(newVal) {\n        textarea.style.color = newVal;\n    });\n}\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'TextEdit',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: QMLTextEdit\n});\n","global.TextInput = {\n  Normal: 0, Password: 1, NoEcho: 2, PasswordEchoOnEdit: 3\n};\n\nregisterQmlType({\n  module:   'QtQuick',\n  name:     'TextInput',\n  versions: /.*/,\n  baseClass: 'Item',\n  constructor: function QMLTextInput(meta) {\n    callSuper(this, meta);\n\n    var self = this;\n\n    this.font = new getConstructor('QtQuick', '2.0', 'Font')(this);\n\n    const input = this.impl = document.createElement('input');\n    input.type = 'text';\n    input.disabled = true;\n    input.style.pointerEvents = \"auto\";\n    // In some browsers text-inputs have a margin by default, which distorts\n    // the positioning, so we need to manually set it to 0.\n    input.style.margin = \"0\";\n    input.style.padding = \"0\";\n    input.style.width = \"100%\";\n    input.style.height = \"100%\";\n    this.dom.appendChild(input);\n\n    this.setupFocusOnDom(input);\n\n    createProperty(\"string\", this, \"text\");\n    createProperty(\"int\", this, \"maximumLength\", {initialValue: -1});\n    createProperty(\"bool\",   this, \"readOnly\");\n    createProperty(\"var\",    this, \"validator\");\n    createProperty(\"enum\",   this, \"echoMode\");\n    this.accepted = Signal();\n    input.disabled = false;\n\n    this.Component.completed.connect(this, function() {\n        this.implicitWidth = input.offsetWidth;\n        this.implicitHeight = input.offsetHeight;\n    });\n\n    this.textChanged.connect(this, function(newVal) {\n        // We have to check if value actually changes.\n        // If we do not have this check, then after user updates text input following occurs:\n        // user update gui text -> updateValue called -> textChanged called -> gui value updates again -> caret position moves to the right!\n        if (input.value != newVal)\n            input.value = newVal;\n    });\n\n    this.echoModeChanged.connect(this, (function(newVal) {\n        switch (newVal) {\n          case TextInput.Normal:\n            input.type = \"text\";\n            break ;\n          case TextInput.Password:\n            input.type = \"password\";\n            break ;\n          case TextInput.NoEcho:\n            // Not supported, use password, that's nearest\n            input.type = \"password\";\n            break;\n          case TextInput.PasswordEchoOnEdit:\n            // Not supported, use password, that's nearest\n            input.type = \"password\";\n            break;\n        }\n    }).bind(this));\n\n    this.maximumLengthChanged.connect(this, function(newVal) {\n        if (newVal < 0)\n          newVal = null;\n        input.maxLength = newVal;\n    });\n\n    this.readOnlyChanged.connect(this, function(newVal) {\n        input.disabled = newVal;\n    });\n\n    this.Keys.pressed.connect(this, (function(e) {\n      if ((e.key == Qt.Key_Return || e.key == Qt.Key_Enter) &&\n          testValidator()) {\n        self.accepted();\n        e.accepted = true;\n      }\n    }).bind(this));\n\n    function testValidator() {\n      if (typeof self.validator != 'undefined' && self.validator != null)\n        return self.validator.validate(self.text);\n      return true;\n    }\n\n    function updateValue(e) {\n        if (self.text != self.dom.firstChild.value) {\n          self.$canEditReadOnlyProperties = true;\n          self.text = self.dom.firstChild.value;\n          self.$canEditReadOnlyProperties = false;\n        }\n    }\n\n    input.oninput = updateValue;\n    input.onpropertychanged = updateValue;\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Timer',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLTimer(meta) {\n    callSuper(this, meta);\n    var prevTrigger,\n        self = this;\n\n    createProperty(\"int\", this, \"interval\", {interval: 1000});\n    createProperty(\"bool\", this, \"repeat\");\n    createProperty(\"bool\", this, \"running\");\n    createProperty(\"bool\", this, \"triggeredOnStart\");\n\n    // Create trigger as simple property. Reading the property triggers\n    // the function!\n    this.triggered = Signal();\n\n    engine.$addTicker(ticker);\n    function ticker(now, elapsed) {\n        if (self.running) {\n            if (now - prevTrigger >= self.interval) {\n                prevTrigger = now;\n                trigger();\n            }\n        }\n    }\n\n    this.start = function() {\n        if (!this.running) {\n            this.running = true;\n            prevTrigger = (new Date).getTime();\n            if (this.triggeredOnStart) {\n                trigger();\n            }\n        }\n    }\n    this.stop = function() {\n        if (this.running) {\n            this.running = false;\n        }\n    }\n    this.restart = function() {\n        this.stop();\n        this.start();\n    }\n\n    function trigger() {\n        if (!self.repeat)\n            // We set the value directly in order to be able to emit the runningChanged\n            // signal after triggered, like Qt does it.\n            self.$properties.running.val = false;\n\n        // Trigger this.\n        self.triggered();\n\n        if (!self.repeat)\n            // Emit changed signal manually after setting the value manually above.\n            self.runningChanged();\n    }\n\n    engine.$registerStart(function() {\n        if (self.running) {\n            self.running = false; // toggled back by self.start();\n            self.start();\n        }\n    });\n\n    engine.$registerStop(function() {\n        self.stop();\n    });\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Transition',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLTransition(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"list\", this, \"animations\");\n    this.$defaultProperty = \"animations\";\n    createProperty(\"string\", this, \"from\", {initialValue: '*'});\n    createProperty(\"string\", this, \"to\", {initialValue: '*'});\n    createProperty(\"bool\", this, \"reversible\");\n    this.$item = this.$parent;\n\n    this.$start = function(actions) {\n        for (var i = 0; i < this.animations.length; i++) {\n            var animation = this.animations[i];\n            animation.$actions = [];\n            for (var j in actions) {\n                var action = actions[j];\n                if ((animation.$targets.length === 0 || animation.$targets.indexOf(action.target) !== -1)\n                    && (animation.$props.length === 0 || animation.$props.indexOf(action.property) !== -1))\n                    animation.$actions.push(action);\n            }\n            animation.start();\n        }\n    }\n    this.$stop = function() {\n        for (var i = 0; i < this.animations.length; i++)\n            this.animations[i].stop();\n    }\n  }\n});\n","registerQmlType({\n  module:   'QtQuick',\n  name:     'Translate',\n  versions: /.*/,\n  baseClass: 'QtObject',\n  constructor: function QMLTranslate(meta) {\n    callSuper(this, meta);\n\n    createProperty(\"real\", this, \"x\");\n    createProperty(\"real\", this, \"y\");\n\n    this.xChanged.connect(this.$parent, this.$parent.$updateTransform);\n    this.yChanged.connect(this.$parent, this.$parent.$updateTransform);\n\n    this.x = 0;\n    this.y = 0;\n  }\n});\n","// WARNING: Can have wrong behavior if url is changed while the socket is in Connecting state.\n// TODO: Recheck everything.\n\nregisterQmlType({\n  module:   'QtWebSockets',\n  name:     'WebSocket',\n  versions: /.*/,\n  baseClass: 'QtQuick.QtObject',\n  constructor: function QMLWebSocket(meta) {\n    callSuper(this, meta);\n\n    // Exports.\n    this.WebSocket = {\n        // status\n        Connecting: 0,\n        Open: 1,\n        Closing: 2,\n        Closed: 3,\n        Error: 4\n    }\n\n    createProperty(\"bool\", this, \"active\");\n    createProperty(\"enum\", this, \"status\");\n    createProperty(\"string\", this, \"errorString\");\n    createProperty(\"url\", this, \"url\");\n\n    this.textMessageReceived = Signal([{type: \"string\", name: \"message\"}]);\n\n    this.status = this.WebSocket.Closed;\n\n    var self = this,\n        socket,\n        reconnect = false;\n\n    this.sendTextMessage = function(message) {\n        if (this.status == this.WebSocket.Open)\n            socket.send(message);\n    }\n\n    function connectSocket() {\n        reconnect = false;\n\n        if (!self.url || !self.active)\n            return;\n\n        self.status = self.WebSocket.Connecting;\n        socket = new WebSocket(self.url);\n        socket.onopen = function() {\n            self.status = self.WebSocket.Open;\n        }\n        socket.onclose = function() {\n            self.status = self.WebSocket.Closed;\n            if (reconnect)\n                connectSocket();\n        }\n        socket.onerror = function(error) {\n            self.errorString = error.message;\n            self.status = self.WebSocket.Error;\n        }\n        socket.onmessage = function(message) {\n            self.textMessageReceived(message.data);\n        }\n    };\n\n    function reconnectSocket() {\n        reconnect = true;\n        if (self.status == self.WebSocket.Open) {\n            self.status = self.WebSocket.Closing;\n            socket.close()\n        } else if (self.status != self.WebSocket.Closing) {\n            connectSocket();\n        }\n    };\n\n    this.statusChanged.connect(this, function(status) {\n        if (status != self.WebSocket.Error)\n            self.errorString = \"\";\n    });\n    this.activeChanged.connect(this, reconnectSocket);\n    this.urlChanged.connect(this, reconnectSocket);\n  }\n});\n"],"sourceRoot":"/source/"}